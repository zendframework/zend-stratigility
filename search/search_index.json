{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"api/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/api/'; window.location = uri.href; });","title":"_api"},{"location":"creating-middleware/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/creating-middleware/'; window.location = uri.href; });","title":"_creating-middleware"},{"location":"error-handlers/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/error-handlers/'; window.location = uri.href; });","title":"_error-handlers"},{"location":"executing-middleware/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/executing-middleware/'; window.location = uri.href; });","title":"_executing-middleware"},{"location":"install/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/install/'; window.location = uri.href; });","title":"_install"},{"location":"middleware/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/middleware/'; window.location = uri.href; });","title":"_middleware"},{"location":"migration/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/migration/'; window.location = uri.href; });","title":"_migration"},{"location":"usage/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { var uri = new URL(window.location.href); uri.pathname = '/zend-stratigility/v3/usage/'; window.location = uri.href; });","title":"_usage"},{"location":"migration/preparing-for-v3/","text":"Preparing for version 3 Since 2.2.0 Version 3 simplifies MiddlewarePipe and Next dramatically by restricting them to PSR-15 interface implementations and typehints. However, this also means a number of backwards compatibility breaks are coming. To help prepare you for the new version, we have provided a number of features you can adopt today in order to make your code forwards-compatible. Additionally, we have marked classes and methods as deprecated where necessary, and trigger E_USER_DEPRECATED errors when using functionality which will no longer be available. Below, we list the various changes, and propose ways in which you can update your code to be forwards-compatible. MiddlewarePipe and path segregation Starting in version 3, MiddlewarePipe and Next have significantly different behavior. First, the signature of MiddlewarePipe::pipe() will change to: public function pipe( MiddlewareInterface $middleware ) : void This means the following: You can no longer use pipe() to perform path segregation. You can no longer pipe callable middleware of any type. To support path segregation, we have introduced Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . This class accepts two arguments to its constructor: a string $pathPrefix (previously, the $path argument to MiddlewarePipe::pipe() ), and a middleware implementation. This class has been backported to version 2.2.0, with usage as follows: // Previously: $pipeline->pipe('/api', $apiMiddleware); // Version 2.2.0+: use Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator; $pipeline->pipe(new PathMiddlewareDecorator('/api', $apiMiddleware)); // OR: use Zend\\Stratigility\\path; $pipeline->pipe(path('/api', $apiMiddleware)); Path segregation using this middleware works exactly as it has in previous versions. (Internally, if you provide both a $path and $middleware argument, MiddlewarePipe::pipe() creates a PathMiddlewareDecorator instance from the two arguments). Decorate middleware you need to segregate by path using PathMiddlewareDecorator or the path() utility function. To support callable middleware, we have introduced two classes: Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator can be used to decorate callable middleware following the PSR-15 signature. It replaces the class CallableInteropMiddlewareWrapper . Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator can be used to decorate callable middleware following the double-pass signature. It replaces the class CallableMiddlewareWrapper . Use these classes to decorate your callable middleware when piping them: // Previously (interop middleware): $pipeline->pipe(function ($request, $delegate) { /* ... */ }); // Version 2.2.0+: use Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator; use Zend\\Stratigility\\middleware; $pipeline->pipe(new CallableMiddlewareDecorator(function ($request, $delegate) { /* ... */ })); // or: $pipeline->pipe(middleware(function ($request, $delegate) { /* ... */ })); // Previously (double-pass middleware): $pipeline->pipe(function ($request, $response, $next) { /* ... */ }); // Version 2.2.0+: use Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator; use Zend\\Stratigility\\doublePassMiddleware; $pipeline->pipe(new DoublePassMiddlewareDecorator(function ($request, $response, $next) { /* ... */ })); // or: $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) { /* ... */ })); If you pipe callables directly, you will now trigger an E_USER_DEPRECATION error. Internally, MiddlewarePipe::pipe() will decorate them using the classes noted above. Decorate callable middleware before piping using either CallableMiddlewareDecorator or DoublePassMiddlewareDecorator or the relevant utility functions as noted in the examples above. Extending MiddlewarePipe Starting in version 3, Zend\\Stratigility\\MiddlewarePipe is marked as final . This means you will no longer be able to directly extend it. We recommend the following: If you are extending the class for the sole purpose of piping specific middleware, create a PSR-15 MiddlewareInterface implementation, and compose a MiddlewarePipe internally; have your process() method proxy to it. (You could also optionally implement RequestHandlerInterface , which MiddlewarePipe does in version 3.) If you are extending the class in order to provide additional features or override methods, create your own PSR-15 MiddlewareInterface implementation to do so, and copy and paste methods from MiddlewarePipe as needed, providing the changes you need within your version. Deprecated classes The following classes are now marked as deprecated. Where alternatives are available, we note them. If no alternative is available, we note why. Zend\\Stratigility\\MiddlewareInterface This interface has been marked as deprecated since 2.0.0, and unused internally since that release. It is removed with version 3.0.0. Zend\\Stratigility\\Route This is an internal message shared between a MiddlewarePipe and a Next instance for purposes of path segregation. In general, it should never be consumed directly; however, it was never marked as internal or final previously. If you are extending this class or manipulating instances manually, be aware that this class is removed in version 3 as it is no longer used internally. Zend\\Stratigility\\Exception\\InvalidMiddlewareException This was thrown by MiddlewarePipe::pipe() . In version 3, since the sole argument to that method is type-hinted against the PSR-15 MiddlewareInterface , it is no longer used. Zend\\Stratigility\\Exception\\InvalidRequestTypeException This has not been used internally since before version 2. Zend\\Stratigility\\Delegate\\CallableDelegateDecorator This was an internal class used by several classes when they were being used within double-pass systems in order to cast a callable $next argument into a Interop\\Http\\ServerMiddleware\\DelegateInterface instance. Since version 3 will no longer support operation directly within a double-pass architecture, this class will be removed. Methods that produce an instance include: - MiddlewarePipe::__invoke() - NotFoundHandler::__invoke() - ErrorHandler::__invoke() Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper This class has been deprecated in favor of a new class, Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator . Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper This class has been deprecated in favor of a new class, Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator . Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory The primary purpose of this class was for composition within a MiddlewarePipe for purposes of decorating callable double-pass middleware. Since MiddlewarePipe::pipe() will no longer accept callables, it will also no longer need to compose this factory. Zend\\Stratigility\\Middleware\\NoopFinalFactory This class has no internal usage, and is removed in version 3.","title":"Preparing for version 3"},{"location":"migration/preparing-for-v3/#preparing-for-version-3","text":"Since 2.2.0 Version 3 simplifies MiddlewarePipe and Next dramatically by restricting them to PSR-15 interface implementations and typehints. However, this also means a number of backwards compatibility breaks are coming. To help prepare you for the new version, we have provided a number of features you can adopt today in order to make your code forwards-compatible. Additionally, we have marked classes and methods as deprecated where necessary, and trigger E_USER_DEPRECATED errors when using functionality which will no longer be available. Below, we list the various changes, and propose ways in which you can update your code to be forwards-compatible.","title":"Preparing for version 3"},{"location":"migration/preparing-for-v3/#middlewarepipe-and-path-segregation","text":"Starting in version 3, MiddlewarePipe and Next have significantly different behavior. First, the signature of MiddlewarePipe::pipe() will change to: public function pipe( MiddlewareInterface $middleware ) : void This means the following: You can no longer use pipe() to perform path segregation. You can no longer pipe callable middleware of any type. To support path segregation, we have introduced Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . This class accepts two arguments to its constructor: a string $pathPrefix (previously, the $path argument to MiddlewarePipe::pipe() ), and a middleware implementation. This class has been backported to version 2.2.0, with usage as follows: // Previously: $pipeline->pipe('/api', $apiMiddleware); // Version 2.2.0+: use Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator; $pipeline->pipe(new PathMiddlewareDecorator('/api', $apiMiddleware)); // OR: use Zend\\Stratigility\\path; $pipeline->pipe(path('/api', $apiMiddleware)); Path segregation using this middleware works exactly as it has in previous versions. (Internally, if you provide both a $path and $middleware argument, MiddlewarePipe::pipe() creates a PathMiddlewareDecorator instance from the two arguments). Decorate middleware you need to segregate by path using PathMiddlewareDecorator or the path() utility function. To support callable middleware, we have introduced two classes: Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator can be used to decorate callable middleware following the PSR-15 signature. It replaces the class CallableInteropMiddlewareWrapper . Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator can be used to decorate callable middleware following the double-pass signature. It replaces the class CallableMiddlewareWrapper . Use these classes to decorate your callable middleware when piping them: // Previously (interop middleware): $pipeline->pipe(function ($request, $delegate) { /* ... */ }); // Version 2.2.0+: use Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator; use Zend\\Stratigility\\middleware; $pipeline->pipe(new CallableMiddlewareDecorator(function ($request, $delegate) { /* ... */ })); // or: $pipeline->pipe(middleware(function ($request, $delegate) { /* ... */ })); // Previously (double-pass middleware): $pipeline->pipe(function ($request, $response, $next) { /* ... */ }); // Version 2.2.0+: use Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator; use Zend\\Stratigility\\doublePassMiddleware; $pipeline->pipe(new DoublePassMiddlewareDecorator(function ($request, $response, $next) { /* ... */ })); // or: $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) { /* ... */ })); If you pipe callables directly, you will now trigger an E_USER_DEPRECATION error. Internally, MiddlewarePipe::pipe() will decorate them using the classes noted above. Decorate callable middleware before piping using either CallableMiddlewareDecorator or DoublePassMiddlewareDecorator or the relevant utility functions as noted in the examples above.","title":"MiddlewarePipe and path segregation"},{"location":"migration/preparing-for-v3/#extending-middlewarepipe","text":"Starting in version 3, Zend\\Stratigility\\MiddlewarePipe is marked as final . This means you will no longer be able to directly extend it. We recommend the following: If you are extending the class for the sole purpose of piping specific middleware, create a PSR-15 MiddlewareInterface implementation, and compose a MiddlewarePipe internally; have your process() method proxy to it. (You could also optionally implement RequestHandlerInterface , which MiddlewarePipe does in version 3.) If you are extending the class in order to provide additional features or override methods, create your own PSR-15 MiddlewareInterface implementation to do so, and copy and paste methods from MiddlewarePipe as needed, providing the changes you need within your version.","title":"Extending MiddlewarePipe"},{"location":"migration/preparing-for-v3/#deprecated-classes","text":"The following classes are now marked as deprecated. Where alternatives are available, we note them. If no alternative is available, we note why.","title":"Deprecated classes"},{"location":"v1/api/","text":"API Reference The following make up the primary API of Stratigility. Middleware Zend\\Stratigility\\MiddlewarePipe is the primary application interface, and has been discussed previously. Its API is: namespace Zend\\Stratigility; use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\MiddlewareInterface as InteropMiddlewareInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class MiddlewarePipe implements MiddlewareInterface, ServerMiddlewareInterface { public function pipe( string|callable|InteropMiddlewareInterface|ServerRequestInterface $path, callable|InteropMiddlewareInterface|ServerRequestInterface $middleware = null ); public function __invoke( ServerRequestInterface, ResponseInterface $response, callable $out = null ) : ResponseInterface; public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } pipe() takes up to two arguments. If only one argument is provided, $middleware will be assigned that value, and $path will be re-assigned to the value / ; this is an indication that the $middleware should be invoked for any path. If $path is provided, the $middleware will only be executed for that path and any subpaths. Request path changes when path matched When you pipe middleware using a path (other than '' or '/'), the middleware is dispatched with a request that strips the matched segment(s) from the start of the path. If, for example, you executed $pipeline->pipe('/api', $api) , and this was matched via a URI with the path /api/users/foo , the $api middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without changes to its own internal routing. Middleware is executed in the order in which it is piped to the MiddlewarePipe instance. The MiddlewarePipe is itself middleware, and can be executed in stacks that expect the __invoke() signature (via the __invoke() signature), or stacks expecting http-interop middleware signatures (via the process() method). When executing the MiddlewarePipe via its __invoke() method, if $out is not provided, an instance of Zend\\Stratigility\\FinalHandler will be created and used in the event that the pipe stack is exhausted ( MiddlewarePipe passes the $response instance it receives to FinalHandler as well, so that the latter can determine if the response it receives is new). $out is no longer optional Starting in version 1.3.0, we now raise a deprecation notice if no argument is passed for the $out argument to __invoke() ; starting in version 2.0.0, the argument will be required. Always pass a Next instance, a Zend\\Stratigility\\NoopFinalHandler instance, or a custom callback; we no longer recommend the FinalHandler implementation. When using __invoke() , the callable $out argument should use the signature: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function ( ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface Within Stratigility, Zend\\Stratigility\\Next provides such an implementation. Starting in version 1.3.0, MiddlewarePipe also implements the http-interop ServerMiddlewareInterface , and thus provides a process() method. This method requires a ServerRequestInterface instance and an Interop\\Http\\Middleware\\DelegateInterface instance on invocation; the latter can be a Next instance, as it also implements that interface. Internally, for both __invoke() and process() , MiddlewarePipe creates an instance of Zend\\Stratigility\\Next , feeding it its queue, executes it, and returns its response. Response prototype Starting in version 1.3.0, you can compose a \"response prototype\" in the MiddlewarePipe . When present, any callable middleware piped to the instance will be wrapped in a decorator (see the section on middleware decorators , below) such that it will now conform to http-interop middleware interfaces. To use this functionality, inject the prototype before piping middleware: $pipeline = new MiddlewarePipe(); $pipeline->setResponsePrototype(new Response()); Next Zend\\Stratigility\\Next is primarily an implementation detail of middleware, and exists to allow delegating to middleware registered later in the stack. It is implemented both as a functor and as an Interop\\Http\\Middleware\\DelegateInterface . Functor invocation Because Psr\\Http\\Message 's interfaces are immutable, if you make changes to your Request and/or Response instances, you will have new instances, and will need to make these known to the next middleware in the chain. Next expects these arguments for every invocation. Additionally, if an error condition has occurred, you may pass an optional third argument, $err , representing the error condition. class Next { public function __invoke( Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response ) : Psr\\Http\\Message\\ResponseInterface; } You should always either capture or return the return value of $next() when calling it in your application. The expected return value is a response instance, but if it is not, you may want to return the response provided to you. $err argument Technically, Next::__invoke() accepts a third, optional argument, $err . However, as of version 1.3.0, this argument is deprecated, and usage will raise a deprecation notice during runtime. We will be removing the argument entirely starting with version 2.0.0. $response argument Using the $response argument is unsafe when using delegation, as an inner layer could return an entirely different response, ignoring any changes you may have introduced previously. Additionally, when manipulating the response from an inner layer, you may be inheriting unwanted context. As such, we recommend ignoring the $response argument and doing one of the following: For innermost middleware that will be returning a response without delegation, we recommend instantiating and returning a concrete response instance. Diactoros provides a number of convenient custom responses . For middleware delegating to another layer, operate on the returned response instead: php $response = $next($request, $response); return $response->withHeader('X-Foo', 'Bar'); Delegate invocation Since 1.3.0. When invoked as a DelegateInterface , the process() method will be invoked, and passed a ServerRequestInterface instance only . If you need to return a response, you will need to: Compose a response prototype in the middleware to use to build a response, or a canned response to return, OR Create and return a concrete response type, OR Operate on a response returned by invoking the delegate. Providing an altered request: // Standard invokable: function ($request, $response, $next) use ($bodyParser) { $bodyParams = $bodyParser($request); return $next( $request->withBodyParams($bodyParams), // Next will pass the new $response // request instance ); } // http-interop invokable: function ($request, DelegateInterface $delegate) use ($bodyParser) { $bodyParams = $bodyParser($request); // Provide a new request instance to the delegate: return $delegate->process( $request->withBodyParams($bodyParams) ); } Returning a response to complete the request If your middleware does not need to delegate to another layer, it's time to return a response. While we pass a response when using Next as a functor, we recommend creating a new response, or providing your middleware with a response prototype; this will ensure that the response is specific for your context. use Interop\\Http\\Middleware\\DelegateInterface; use Zend\\Diactoros\\Response; $prototype = new Response(); // Standard invokable signature: function ($request, $response, $next) use ($prototype) { $response = $prototype->withAddedHeader('Cache-Control', [ 'public', 'max-age=18600', 's-maxage=18600', ]); return $response; } // http-interop invokable signature: function ($request, DelegateInterface $delegate) use ($prototype) { $response = $prototype->withAddedHeader('Cache-Control', [ 'public', 'max-age=18600', 's-maxage=18600', ]); return $response; } Delegation If your middleware is not capable of returning a response, or a particular path in the middleware cannot return a response, return the result of executing the delegate. If using the legacy middleware signature, invoke the $next argument: return $next($request, $response); If using a DelegateInterface , invoke its process() method: return $delegate->process($request); Middleware should always return a response, and, if it cannot, return the result of delegation. Raising an error condition Deprecated as of 1.3.0; please use exceptions and a error handling middleware such as the ErrorHandler to handle error conditions in your application instead. To raise an error condition, pass a non-null value as the third argument to $next() : function ($request, $response, $next) { try { // try some operation... } catch (Exception $e) { return $next($request, $response, $e); // Next registered error middleware will be invoked } } FinalHandler Deprecated starting with 1.3.0. Use Zend\\Stratigility\\NoopFinalHandler or a custom handler guaranteed to return a response instead. Zend\\Stratigility\\FinalHandler is a default implementation of middleware to execute when the stack exhausts itself. It expects three arguments when invoked: a request instance, a response instance, and an error condition (or null for no error). It returns a response. FinalHandler allows two optional arguments during instantiation $options , an array of options with which to configure itself. These options currently include: env , the application environment. If set to \"production\", no stack traces will be provided. onerror , a callable to execute if an error is passed when FinalHandler is invoked. The callable is invoked with the error (which will be null in the absence of an error), the request, and the response, in that order. Psr\\Http\\Message\\ResponseInterface $response ; if passed, it will compare the response passed during invocation against this instance; if they are different, it will return the response from the invocation, as this indicates that one or more middleware provided a new response instance. Internally, FinalHandler does the following on invocation: If $error is non- null , it creates an error response from the response provided at invocation, ensuring a 400 or 500 series response is returned. If the response at invocation matches the response provided at instantiation, it returns it without further changes. This is an indication that some middleware at some point in the execution chain called $next() with a new response instance. If the response at invocation does not match the response provided at instantiation, or if no response was provided at instantiation, it creates a 404 response, as the assumption is that no middleware was capable of handling the request. HTTP Messages Zend\\Stratigility\\Http\\Request Deprecated in 1.3.0; to be removed in 2.0.0. Zend\\Stratigility\\Http\\Request acts as a decorator for a Psr\\Http\\Message\\ServerRequestInterface instance. The primary reason is to allow composing middleware such that you always have access to the original request instance. As an example, consider the following: $app1 = new Middleware(); $app1->pipe('/foo', $fooCallback); $app2 = new Middleware(); $app2->pipe('/root', $app1); $server = Server::createServer($app2 /* ... */); In the above, if the URI of the original incoming request is /root/foo , what $fooCallback will receive is a URI with a past consisting of only /foo . This practice ensures that middleware can be nested safely and resolve regardless of the nesting level. If you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your current middleware \u2014 Zend\\Stratigility\\Http\\Request contains a method, getOriginalRequest() , which will always return the original request provided to the application: function ($request, $response, $next) { $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]'; $response = $response->setHeader('Location', $location); $response = $response->setStatus(302); return $response; } Zend\\Stratigility\\Http\\Response Deprecated in 1.3.0; to be removed in 2.0.0. Zend\\Stratigility\\Http\\Response acts as a decorator for a Psr\\Http\\Message\\ResponseInterface instance, and also implements Zend\\Stratigility\\Http\\ResponseInterface , which provides the following convenience methods: write() , which proxies to the write() method of the composed response stream. end() , which marks the response as complete; it can take an optional argument, which, when provided, will be passed to the write() method. Once end() has been called, the response is immutable and will throw an exception if a state mutating method like withHeader is called. isComplete() indicates whether or not end() has been called. Additionally, it provides access to the original response created by the server via the method getOriginalResponse() . Middleware Stratigility provides several concrete middleware implementations. ErrorHandler and NotFoundHandler These two middleware allow you to provide handle PHP errors and exceptions, and 404 conditions, respectively. You may read more about them in the error handling chapter . OriginalMessages This callable middleware can be used as the outermost layer of middleware in order to set the original request, URI, and response instances as request attributes for inner layers. See the v2 migration chapter for more details. Middleware Decorators Starting in version 1.3.0, we offer the ability to work with http-interop middleware. Internally, if a response prototype is composed in the MiddlewarePipe , callable middleware piped to the MiddlewarePipe will be wrapped in one of these decorators. Two versions exist: Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable using the legacy interface; as such, it also requires a response instance: php $middleware = new CallableMiddlewareWrapper($middleware, $response); Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable that defines exactly two arguments, with the second type-hinting on Interop\\Http\\Middleware\\DelegateInterface : php $middleware = new CallableMiddlewareWrapper( function ($request, DelegateInterface $delegate) { // ... } ); You can manually decorate callable middleware using these decorators, or simply let MiddlewarePipe do the work for you. To let MiddlewarePipe handle this, however, you must compose a response prototype prior to piping middleware using the legacy middleware signature. Delegates In addition to Zend\\Stratigility\\Next , Stratigility provides another Interop\\Http\\Middleware\\DelegateInterface implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator . This class can be used to wrap a callable $next instance for use in passing to a ServerMiddlewareInterface::process() method as a delegate; the primary use case is adapting functor middleware to work as http-interop middleware. As an example: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Stratigility\\Delegate\\CallableDelegateDecorator; class TimestampMiddleware implements ServerMiddlewareInterface { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { return $this->process($request, new CallableDelegateDecorator($next, $response)); } public function process( ServerRequestInterface $request, DelegateInterface $delegate ) { $response = $delegate->process($request); return $response->withHeader('X-Processed-Timestamp', time()); } }","title":"API Reference"},{"location":"v1/api/#api-reference","text":"The following make up the primary API of Stratigility.","title":"API Reference"},{"location":"v1/api/#middleware","text":"Zend\\Stratigility\\MiddlewarePipe is the primary application interface, and has been discussed previously. Its API is: namespace Zend\\Stratigility; use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\MiddlewareInterface as InteropMiddlewareInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class MiddlewarePipe implements MiddlewareInterface, ServerMiddlewareInterface { public function pipe( string|callable|InteropMiddlewareInterface|ServerRequestInterface $path, callable|InteropMiddlewareInterface|ServerRequestInterface $middleware = null ); public function __invoke( ServerRequestInterface, ResponseInterface $response, callable $out = null ) : ResponseInterface; public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } pipe() takes up to two arguments. If only one argument is provided, $middleware will be assigned that value, and $path will be re-assigned to the value / ; this is an indication that the $middleware should be invoked for any path. If $path is provided, the $middleware will only be executed for that path and any subpaths.","title":"Middleware"},{"location":"v1/api/#next","text":"Zend\\Stratigility\\Next is primarily an implementation detail of middleware, and exists to allow delegating to middleware registered later in the stack. It is implemented both as a functor and as an Interop\\Http\\Middleware\\DelegateInterface .","title":"Next"},{"location":"v1/api/#finalhandler","text":"Deprecated starting with 1.3.0. Use Zend\\Stratigility\\NoopFinalHandler or a custom handler guaranteed to return a response instead. Zend\\Stratigility\\FinalHandler is a default implementation of middleware to execute when the stack exhausts itself. It expects three arguments when invoked: a request instance, a response instance, and an error condition (or null for no error). It returns a response. FinalHandler allows two optional arguments during instantiation $options , an array of options with which to configure itself. These options currently include: env , the application environment. If set to \"production\", no stack traces will be provided. onerror , a callable to execute if an error is passed when FinalHandler is invoked. The callable is invoked with the error (which will be null in the absence of an error), the request, and the response, in that order. Psr\\Http\\Message\\ResponseInterface $response ; if passed, it will compare the response passed during invocation against this instance; if they are different, it will return the response from the invocation, as this indicates that one or more middleware provided a new response instance. Internally, FinalHandler does the following on invocation: If $error is non- null , it creates an error response from the response provided at invocation, ensuring a 400 or 500 series response is returned. If the response at invocation matches the response provided at instantiation, it returns it without further changes. This is an indication that some middleware at some point in the execution chain called $next() with a new response instance. If the response at invocation does not match the response provided at instantiation, or if no response was provided at instantiation, it creates a 404 response, as the assumption is that no middleware was capable of handling the request.","title":"FinalHandler"},{"location":"v1/api/#http-messages","text":"","title":"HTTP Messages"},{"location":"v1/api/#middleware_1","text":"Stratigility provides several concrete middleware implementations.","title":"Middleware"},{"location":"v1/api/#middleware-decorators","text":"Starting in version 1.3.0, we offer the ability to work with http-interop middleware. Internally, if a response prototype is composed in the MiddlewarePipe , callable middleware piped to the MiddlewarePipe will be wrapped in one of these decorators. Two versions exist: Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable using the legacy interface; as such, it also requires a response instance: php $middleware = new CallableMiddlewareWrapper($middleware, $response); Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable that defines exactly two arguments, with the second type-hinting on Interop\\Http\\Middleware\\DelegateInterface : php $middleware = new CallableMiddlewareWrapper( function ($request, DelegateInterface $delegate) { // ... } ); You can manually decorate callable middleware using these decorators, or simply let MiddlewarePipe do the work for you. To let MiddlewarePipe handle this, however, you must compose a response prototype prior to piping middleware using the legacy middleware signature.","title":"Middleware Decorators"},{"location":"v1/api/#delegates","text":"In addition to Zend\\Stratigility\\Next , Stratigility provides another Interop\\Http\\Middleware\\DelegateInterface implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator . This class can be used to wrap a callable $next instance for use in passing to a ServerMiddlewareInterface::process() method as a delegate; the primary use case is adapting functor middleware to work as http-interop middleware. As an example: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Stratigility\\Delegate\\CallableDelegateDecorator; class TimestampMiddleware implements ServerMiddlewareInterface { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { return $this->process($request, new CallableDelegateDecorator($next, $response)); } public function process( ServerRequestInterface $request, DelegateInterface $delegate ) { $response = $delegate->process($request); return $response->withHeader('X-Processed-Timestamp', time()); } }","title":"Delegates"},{"location":"v1/creating-middleware/","text":"Creating Middleware To create middleware, write a callable capable of receiving minimally PSR-7 ServerRequest and Response objects, and a callback to call the next middleware in the chain. In your middleware, you can handle as much or as little of the request as you want, including delegating to other middleware. By accepting the third argument, $next , it can allow further processing via invoking that argument, or return handling to the parent middleware by returning a response. As an example, consider the following middleware which will use an external router to map the incoming request path to a handler; if unable to map the request, it returns processing to the next middleware. function ($req, $res, $next) use ($router) { $path = $req->getUri()->getPath(); // Route the path $route = $router->route($path); if (! $route) { return $next($req, $res); } $handler = $route->getHandler(); return $handler($req, $res, $next); } Middleware written in this way can be any of the following: Closures (as shown above) Functions Static class methods PHP array callbacks (e.g., [ $dispatcher, 'dispatch' ] , where $dispatcher is a class instance) Invokable PHP objects (i.e., instances of classes implementing __invoke() ) Objects implementing Zend\\Stratigility\\MiddlewareInterface (including Zend\\Stratigility\\MiddlewarePipe ) In all cases, if you wish to implement typehinting, the signature is: function ( Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response, callable $next ) : Psr\\Http\\Message\\ResponseInterface Legacy error middleware Deprecated since 1.3.0; to be removed in version 2.0.0. Please use the the NotFoundHandler and ErrorHandler detailed in the error handling chapter , or equivalents. The implementation Stratigility offers also allows you to write specialized error handler middleware. The signature is the same as for normal middleware, except that it expects an additional argument prepended to the signature, $error . (Alternately, you can implement Zend\\Stratigility\\ErrorMiddlewareInterface .) The signature is: function ( $error, // Can be any type Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response, callable $next ) : Psr\\Http\\Message\\ResponseInterface","title":"Creating Middleware"},{"location":"v1/creating-middleware/#creating-middleware","text":"To create middleware, write a callable capable of receiving minimally PSR-7 ServerRequest and Response objects, and a callback to call the next middleware in the chain. In your middleware, you can handle as much or as little of the request as you want, including delegating to other middleware. By accepting the third argument, $next , it can allow further processing via invoking that argument, or return handling to the parent middleware by returning a response. As an example, consider the following middleware which will use an external router to map the incoming request path to a handler; if unable to map the request, it returns processing to the next middleware. function ($req, $res, $next) use ($router) { $path = $req->getUri()->getPath(); // Route the path $route = $router->route($path); if (! $route) { return $next($req, $res); } $handler = $route->getHandler(); return $handler($req, $res, $next); } Middleware written in this way can be any of the following: Closures (as shown above) Functions Static class methods PHP array callbacks (e.g., [ $dispatcher, 'dispatch' ] , where $dispatcher is a class instance) Invokable PHP objects (i.e., instances of classes implementing __invoke() ) Objects implementing Zend\\Stratigility\\MiddlewareInterface (including Zend\\Stratigility\\MiddlewarePipe ) In all cases, if you wish to implement typehinting, the signature is: function ( Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response, callable $next ) : Psr\\Http\\Message\\ResponseInterface","title":"Creating Middleware"},{"location":"v1/error-handlers/","text":"Error Handlers In your application, you may need to handle error conditions: Errors raised by PHP itself (e.g., inability to open a file or database connection). Exceptions/throwables raised by PHP and/or code you write or consume. Inability of any middleware to handle a request. You can typically handle these conditions via middleware itself. Handling 404 conditions Since 1.3.0 If no middleware is able to handle the incoming request, this is typically representative of an HTTP 404 status. Stratigility provides a barebones middleware that you may register in an innermost layer that will return a 404 condition, Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a response prototype instance that it will use to provide the 404 status and a message indicating the request method and URI used: // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); $app->pipe(new NotFoundHandler(new Response()); // execute application Note that it is the last middleware piped into the application! Since it returns a response, no deeper nested layers will execute once it has been invoked. If you would like a templated response, you will need to write your own middleware; such middleware might look like the following: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class NotFoundMiddleware implements ServerMiddlewareInterface { private $renderer; public function __construct( TemplateRendererInterface $renderer, ResponseInterface $response ) { $this->renderer = $renderer; $this->response = $response; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $this->response->withStatus(404); $response->getBody()->write( $this->renderer->render('error::404') ); return $response; } } Handling PHP errors and exceptions Since 1.3.0 Opting in to error middleware If you have upgraded from Expressive 1.0.0, you will have been using the FinalHandler implementation, and relying on the fact that, internally, dispatching wraps all middleware in try/catch blocks. Starting in 1.3.0, we provide a new way to handle errors via middleware. To opt-in to the new system, you must call raiseThrowables() on your middleware pipeline: php $pipeline = new MiddlewarePipe(); $pipeline->raiseThrowables(); (Starting in 2.0.0, this will no longer be necessary, but until then, this is how you opt-in to the system described below.) Zend\\Stratigility\\Middleware\\ErrorHandler is a middleware implementation to register as the outermost layer of your application (or close to the outermost layer). It does the following: Creates a PHP error handler that catches any errors in the error_handling() mask and throws them as ErrorException instances. Wraps the invocation of the delegate in a try/catch block: if no exception is caught, and the result is a response, it returns it. if no exception is caught, it raises an exception, which will be caught. any caught exception is transformed into an error response. To generate the error response, we provide the ability to inject a callable with the following signature into the ErrorHandler during instantiation: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface We provide a default implementation, Zend\\Stratigility\\Middleware\\ErrorResponseGenerator , which generates an error response with a 5XX series status code and a message derived from the reason phrase, if any is present. You may pass a boolean flag to its constructor indicating the application is in development mode; if so, the response will have the stack trace included in the body. In order to work, the ErrorHandler needs a prototype response instance, and, optionally, an error response generator (if none is provided, ErrorResponseGenerator is used, in production mode): // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); As a full example, you can combine the two middleware into the same application as separate layers: // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); // setup 404 handling $app->pipe(new NotFoundHandler(new Response()); // execute application The ErrorResponseGenerator provides no templating facilities, and only responds as text/html . If you want to provide a templated response, or a different serialization and/or markup format, you will need to write your own error response generator. As an example: use ErrorException; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Throwable; use Zend\\Stratigility\\Exception\\MissingResponseException; use Zend\\Stratigility\\Middleware\\ErrorHandler; class TemplatedErrorResponseGenerator { private $isDevelopmentMode; private $renderer; public function __construct( TemplateRendererInterface $renderer, $isDevelopmentMode = false ) { $this->renderer = $renderer; $this->isDevelopmentMode = $isDevelopmentMode; } public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response) { $response = $response->withStatus(500); $response->getBody()->write($this->renderer->render('error::error', [ 'exception' => $e, 'development_mode' => $this->isDevelopmentMode, ])); return $response; } } You would then pass this to the ErrorHandler : $app->pipe(new ErrorHandler( new Response(), new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode) )); ErrorHandler Listeners Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to attach listeners ; these are triggered when an error or exception is caught, and provided with the exception/throwable raised, the original request, and the final response. These instances are considered immutable, so listeners are for purposes of logging/monitoring only. Listeners must implement the following signature: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : void Attach listeners using ErrorHandler::attachListener() : $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) { $message = sprintf( '[%s] %s %s: %s', date('Y-m-d H:i:s'), $request->getMethod(), (string) $request->getUri(), $throwable->getMessage() ); $logger->error($message); }); Legacy error middleware Deprecated starting in 1.3.0, to be removed in 2.0.0. Please see the v2 migration guide for more details, as well as the preceding section. To handle errors, you can write middleware that accepts exactly four arguments: function ($error, $request, $response, $next) { } Alternately, you can implement Zend\\Stratigility\\ErrorMiddlewareInterface . When using MiddlewarePipe , as the queue is executed, if $next() is called with an argument, or if an exception is thrown, middleware will iterate through the queue until the first such error handler is found. That error handler can either complete the request, or itself call $next() . Error handlers that call $next() SHOULD call it with the error it received itself, or with another error. Error handlers are usually attached at the end of middleware, to prevent attempts at executing non-error-handling middleware, and to ensure they can intercept errors from any other handlers.","title":"Error Handlers"},{"location":"v1/error-handlers/#error-handlers","text":"In your application, you may need to handle error conditions: Errors raised by PHP itself (e.g., inability to open a file or database connection). Exceptions/throwables raised by PHP and/or code you write or consume. Inability of any middleware to handle a request. You can typically handle these conditions via middleware itself.","title":"Error Handlers"},{"location":"v1/error-handlers/#handling-404-conditions","text":"Since 1.3.0 If no middleware is able to handle the incoming request, this is typically representative of an HTTP 404 status. Stratigility provides a barebones middleware that you may register in an innermost layer that will return a 404 condition, Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a response prototype instance that it will use to provide the 404 status and a message indicating the request method and URI used: // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); $app->pipe(new NotFoundHandler(new Response()); // execute application Note that it is the last middleware piped into the application! Since it returns a response, no deeper nested layers will execute once it has been invoked. If you would like a templated response, you will need to write your own middleware; such middleware might look like the following: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class NotFoundMiddleware implements ServerMiddlewareInterface { private $renderer; public function __construct( TemplateRendererInterface $renderer, ResponseInterface $response ) { $this->renderer = $renderer; $this->response = $response; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $this->response->withStatus(404); $response->getBody()->write( $this->renderer->render('error::404') ); return $response; } }","title":"Handling 404 conditions"},{"location":"v1/error-handlers/#handling-php-errors-and-exceptions","text":"Since 1.3.0","title":"Handling PHP errors and exceptions"},{"location":"v1/error-handlers/#legacy-error-middleware","text":"Deprecated starting in 1.3.0, to be removed in 2.0.0. Please see the v2 migration guide for more details, as well as the preceding section. To handle errors, you can write middleware that accepts exactly four arguments: function ($error, $request, $response, $next) { } Alternately, you can implement Zend\\Stratigility\\ErrorMiddlewareInterface . When using MiddlewarePipe , as the queue is executed, if $next() is called with an argument, or if an exception is thrown, middleware will iterate through the queue until the first such error handler is found. That error handler can either complete the request, or itself call $next() . Error handlers that call $next() SHOULD call it with the error it received itself, or with another error. Error handlers are usually attached at the end of middleware, to prevent attempts at executing non-error-handling middleware, and to ensure they can intercept errors from any other handlers.","title":"Legacy error middleware"},{"location":"v1/executing-middleware/","text":"Executing and composing middleware The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe instance. You can nest MiddlewarePipe instances to create groups of related middleware, and attach them using a base path so they only execute if that path is matched. $api = new MiddlewarePipe(); // API middleware collection $api->pipe(/* ... */); // repeat as necessary $app = new MiddlewarePipe(); // Middleware representing the application $app->pipe('/api', $api); // API middleware attached to the path \"/api\" Request path changes when path matched When you pipe middleware using a path (other than '' or '/'), the middleware is dispatched with a request that strips the matched segment(s) from the start of the path. Using the previous example, if the path /api/users/foo is matched, the $api middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without changes to its own internal routing. Another approach is to extend the Zend\\Stratigility\\MiddlewarePipe class itself, particularly if you want to allow attaching other middleware to your own middleware. In such a case, you will generally override the process() method to perform any additional logic you have, and then call on the parent in order to iterate through your stack of middleware: use Interop\\Http\\Middleware\\DelegateInterface; use Psr\\Http\\Message\\ServerRequestInterface as Request; use Psr\\Http\\Message\\ResponseInterface as Response; use Zend\\Stratigility\\MiddlewarePipe; class CustomMiddleware extends MiddlewarePipe { public function process(Request $request, DelegateInterface $delegate) { // perform some work... // delegate to parent parent::process($request, $delegate); // maybe do more work? } } Another approach using this method would be to override the constructor to add in specific middleware, perhaps using configuration provided. In this case, make sure to also call parent::__construct() to ensure the middleware queue is initialized; we recommend doing this as the first action of the method. use Zend\\Stratigility\\MiddlewarePipe; class CustomMiddleware extends MiddlewarePipe { public function __construct($configuration) { parent::__construct(); // do something with configuration ... // attach some middleware ... $this->pipe(/* some middleware */); } } These approaches are particularly suited for cases where you may want to implement a specific workflow for an application segment using existing middleware, but do not necessarily want that middleware applied to all requests in the application.","title":"Executing and composing middleware"},{"location":"v1/executing-middleware/#executing-and-composing-middleware","text":"The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe instance. You can nest MiddlewarePipe instances to create groups of related middleware, and attach them using a base path so they only execute if that path is matched. $api = new MiddlewarePipe(); // API middleware collection $api->pipe(/* ... */); // repeat as necessary $app = new MiddlewarePipe(); // Middleware representing the application $app->pipe('/api', $api); // API middleware attached to the path \"/api\"","title":"Executing and composing middleware"},{"location":"v1/install/","text":"Installation and Requirements Install this library using composer: $ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^1.0 Stratigility has the following dependencies (which are managed by Composer): psr/http-message , which provides the interfaces specified in PSR-7 , and type-hinted against in this package. In order to use Stratigility, you will need an implementation of PSR-7; one such package is Diactoros . http-interop/http-middleware , which provides the interfaces that will become PSR-15. This is pinned to the 0.2 series. zendframework/zend-escaper , used by the ErrorHandler middleware and the (legacy) FinalHandler implementation for escaping error messages prior to passing them to the response. You can provide your own request and response implementations if desired as long as they implement the PSR-7 HTTP message interfaces. Later versions Version 2 documentation Version 3 (current) documentation","title":"Installation and Requirements"},{"location":"v1/install/#installation-and-requirements","text":"Install this library using composer: $ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^1.0 Stratigility has the following dependencies (which are managed by Composer): psr/http-message , which provides the interfaces specified in PSR-7 , and type-hinted against in this package. In order to use Stratigility, you will need an implementation of PSR-7; one such package is Diactoros . http-interop/http-middleware , which provides the interfaces that will become PSR-15. This is pinned to the 0.2 series. zendframework/zend-escaper , used by the ErrorHandler middleware and the (legacy) FinalHandler implementation for escaping error messages prior to passing them to the response. You can provide your own request and response implementations if desired as long as they implement the PSR-7 HTTP message interfaces.","title":"Installation and Requirements"},{"location":"v1/install/#later-versions","text":"Version 2 documentation Version 3 (current) documentation","title":"Later versions"},{"location":"v1/middleware/","text":"Middleware What is middleware? Middleware is code that exists between the request and response, and which can take the incoming request, perform actions based on it, and either complete the response or pass delegation on to the next middleware in the queue. use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES); // Landing page $app->pipe('/', function ($req, $res, $next) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $next($req, $res); } $res->getBody()->write('Hello world!'); return $res; }); // Another page $app->pipe('/foo', function ($req, $res, $next) { $res->getBody()->write('FOO!'); return $res; }); $server->listen(); In the above example, we have two examples of middleware. The first is a landing page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next middleware in the stack. The second middleware matches on the path /foo \u2014 meaning it will match /foo , /foo/ , and any path beneath. In that case, it will complete the response with its own message. If no paths match at this point, a \"final handler\" is composed by default to report 404 status. So, concisely put, middleware are PHP callables that accept a request and response object, and do something with it . http-interop middleware The above example demonstrates the legacy (pre-1.3.0) signature for middleware, which is also widely used across other middleware frameworks such as Slim, Relay, Adroit, etc. http-interop is a project attempting to standardize middleware signatures. The signature it uses for server-side middleware is: ```php namespace Interop\\Http\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; interface ServerMiddlewareInterface { public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } ``` where DelegateInterface is defined as: ```php namespace Interop\\Http\\Middleware; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; interface DelegateInterface { public function process( RequestInterface $request ) : ResponseInterface; } ``` Stratigility allows you to implement ServerMiddlewareInterface to provide middleware. Additionally, you can define callable middleware with the following signature, and it will be dispatched as http-interop middleware: php function( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; (The $request argument does not require a typehint when defining callable middleware, but we encourage its use.) As such, the above example can also be written as follows: ```php use Interop\\Http\\Middleware\\DelegateInterface; use Zend\\Diactoros\\Response\\TextResponse; $app->pipe('/', function ($req, DelegateInterface $delegate) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $delegate->process($req); } return new TextResponse('Hello world!'); }); ``` Middleware can decide more processing can be performed by calling the $next callable (or, when defining http-interop middleware, $delegate ) passed during invocation. With this paradigm, you can build a workflow engine for handling requests \u2014 for instance, you could have middleware perform the following: Handle authentication details Perform content negotiation Perform HTTP negotiation Route the path to a more appropriate, specific handler Each middleware can itself be middleware, and can attach to specific paths, allowing you to mix and match applications under a common domain. As an example, you could put API middleware next to middleware that serves its documentation, next to middleware that serves files, and segregate each by URI: $app->pipe('/api', $apiMiddleware); $app->pipe('/docs', $apiDocMiddleware); $app->pipe('/files', $filesMiddleware); The handlers in each middleware attached this way will see a URI with that path segment stripped, allowing them to be developed separately and re-used under any path you wish. Within Stratigility, middleware can be: Any PHP callable that accepts, minimally, a PSR-7 ServerRequest and Response (in that order), and, optionally, a callable (for invoking the next middleware in the queue, if any). Any http-interop 0.2.0 - middleware . Zend\\Stratigility\\MiddlewarePipe implements Interop\\Http\\Middleware\\ServerMiddlewareInterface . An object implementing Zend\\Stratigility\\MiddlewareInterface . Zend\\Stratigility\\MiddlewarePipe implements this interface. (Legacy; this interface is deprecated starting in 1.3.0.)","title":"Middleware"},{"location":"v1/middleware/#middleware","text":"What is middleware? Middleware is code that exists between the request and response, and which can take the incoming request, perform actions based on it, and either complete the response or pass delegation on to the next middleware in the queue. use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES); // Landing page $app->pipe('/', function ($req, $res, $next) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $next($req, $res); } $res->getBody()->write('Hello world!'); return $res; }); // Another page $app->pipe('/foo', function ($req, $res, $next) { $res->getBody()->write('FOO!'); return $res; }); $server->listen(); In the above example, we have two examples of middleware. The first is a landing page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next middleware in the stack. The second middleware matches on the path /foo \u2014 meaning it will match /foo , /foo/ , and any path beneath. In that case, it will complete the response with its own message. If no paths match at this point, a \"final handler\" is composed by default to report 404 status. So, concisely put, middleware are PHP callables that accept a request and response object, and do something with it .","title":"Middleware"},{"location":"v1/usage/","text":"Usage Creating an application consists of 3 steps: Create middleware or a middleware pipeline Create a server, using the middleware Instruct the server to listen for a request use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Stratigility\\NoopFinalHandler; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); $server->listen(new NoopFinalHandler()); The above example is useless by itself until you pipe middleware into the application.","title":"Usage"},{"location":"v1/usage/#usage","text":"Creating an application consists of 3 steps: Create middleware or a middleware pipeline Create a server, using the middleware Instruct the server to listen for a request use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Stratigility\\NoopFinalHandler; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); $server->listen(new NoopFinalHandler()); The above example is useless by itself until you pipe middleware into the application.","title":"Usage"},{"location":"v2/api/","text":"API Reference The following make up the primary API of Stratigility. Middleware Zend\\Stratigility\\MiddlewarePipe is the primary application interface, and has been discussed previously. Its API is: namespace Zend\\Stratigility; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class MiddlewarePipe implements ServerMiddlewareInterface { public function pipe( string|callable|ServerMiddlewareInterface $path, callable|ServerMiddlewareInterface $middleware = null ); public function __invoke( ServerRequestInterface $request, ResponseInterface $response, $delegate ) : ResponseInterface; public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } pipe() takes up to two arguments. If only one argument is provided, $middleware will be assigned that value, and $path will be re-assigned to the value / ; this is an indication that the $middleware should be invoked for any path. If $path is provided, the $middleware will only be executed for that path and any subpaths. Request path changes when path matched When you pipe middleware using a path (other than '' or '/'), the middleware is dispatched with a request that strips the matched segment(s) from the start of the path. If, for example, you executed $pipeline->pipe('/api', $api) , and this was matched via a URI with the path /api/users/foo , the $api middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without changes to its own internal routing. Middleware is executed in the order in which it is piped to the MiddlewarePipe instance. The MiddlewarePipe is itself middleware, and can be executed in stacks that expect the __invoke() signature (via the __invoke() signature), or stacks expecting http-interop middleware signatures (via the process() method). When using __invoke() , the callable $out argument should either implement delegator/request handler interface from http-interop/http-middleware (depends on version you are using), or use the signature: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function ( ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface Most often, you can pass an instance of Zend\\Stratigility\\NoopFinalHandler for $out if invoking a middleware pipeline manually; otherwise, a suitable callback will be provided for you (typically an instance of Zend\\Stratigility\\Next , which MiddlewarePipe creates internally before dispatching to the various middleware in its pipeline). Middleware should either return a response, or the result of $next()/DelegateInterface::process()/RequestHandlerInterface::handle() (which should eventually evaluate to a response instance). Within Stratigility, Zend\\Stratigility\\Next provides an implementation compatible with either usage. MiddlewarePipe implements the http-interop/http-middleware server-side middleware interface, and thus provides a process() method. This method requires a ServerRequestInterface instance and an http-interop/http-middleware DelegateInterface instance on invocation; the latter can be a Next instance, as it also implements that interface. Internally, for both __invoke() and process() , MiddlewarePipe creates an instance of Zend\\Stratigility\\Next (feeding it its queue), executes it, and returns its response. Response prototype You may compose a \"response prototype\" in the MiddlewarePipe . When present, any callable middleware piped to the instance will be wrapped in a decorator (see the section on middleware decorators , below) such that it will now conform to http-interop middleware interfaces. To use this functionality, inject the prototype before piping middleware: $pipeline = new MiddlewarePipe(); $pipeline->setResponsePrototype(new Response()); Next Zend\\Stratigility\\Next is primarily an implementation detail of middleware, and exists to allow delegating to middleware registered later in the stack. It is implemented both as a functor and as an http-interop/http-middleware DelegateInterface . Functor invocation Because Psr\\Http\\Message 's interfaces are immutable, if you make changes to your Request and/or Response instances, you will have new instances, and will need to make these known to the next middleware in the chain. Next expects these arguments for every invocation. class Next { public function __invoke( Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response ) : Psr\\Http\\Message\\ResponseInterface; } You should always either capture or return the return value of $next() when calling it in your application, or return a response yourself. $response argument Using the $response argument is unsafe when using delegation, as an inner layer could return an entirely different response, ignoring any changes you may have introduced previously. Additionally, when manipulating the response from an inner layer, you may be inheriting unwanted context. As such, we recommend ignoring the $response argument and doing one of the following: For innermost middleware that will be returning a response without delegation, we recommend instantiating and returning a concrete response instance. Diactoros provides a number of convenient custom responses . For middleware delegating to another layer, operate on the returned response instead: php $response = $next($request, $response); return $response->withHeader('X-Foo', 'Bar'); Delegate invocation When invoked as a DelegateInterface , the process() method will be invoked, and passed a ServerRequestInterface instance only . If you need to return a response, you will need to: Compose a response prototype in the middleware to use to build a response, or a canned response to return, OR Create and return a concrete response type, OR Operate on a response returned by invoking the delegate. Providing an altered request: // Standard invokable: function ($request, $response, $next) use ($bodyParser) { $bodyParams = $bodyParser($request); return $next( $request->withBodyParams($bodyParams), // Next will pass the new $response // request instance ); } // http-interop invokable: function ($request, DelegateInterface $delegate) use ($bodyParser) { $bodyParams = $bodyParser($request); // Delegate will receive the new request instance: return $delegate->process( $request->withBodyParams($bodyParams) ); } Providing an altered request and operating on the returned response: function ($request, $response, $next) use ($bodyParser) { $response = $next( $request->withBodyParams($bodyParser($request)), $response ); return $response->withAddedHeader('Cache-Control', [ } // http-interop invokable: function ($request, DelegateInterface $delegate) use ($bodyParser) { $bodyParams = $bodyParser($request); // Provide a new request instance to the delegate: return $delegate->process( $request->withBodyParams($bodyParams) ); } Returning a response to complete the request If your middleware does not need to delegate to another layer, it's time to return a response. While we pass a response when using Next as a functor, we recommend creating a new response, or providing your middleware with a response prototype; this will ensure that the response is specific for your context. $prototype = new Response(); // Standard invokable signature: function ($request, $response, $next) use ($prototype) { $response = $prototype->withAddedHeader('Cache-Control', [ 'public', 'max-age=18600', 's-maxage=18600', ]); return $response; } // http-interop invokable signature: function ($request, DelegateInterface $delegate) use ($prototype) { $response = $prototype->withAddedHeader('Cache-Control', [ 'public', 'max-age=18600', 's-maxage=18600', ]); } Delegation If your middleware is not capable of returning a response, or a particular path in the middleware cannot return a response, return the result of executing the delegate. If using the legacy middleware signature, invoke the $next argument: return $next($request, $response); If using a DelegateInterface , invoke its process() method: return $delegate->process($request); Middleware should always return a response, and, if it cannot, return the result of delegation. Raising an error condition If your middleware cannot complete \u2014 perhaps a database error occurred, a service was unreachable, etc. \u2014 how can you report the error? Raise an exception! function ($request, $response, $next) use ($service) { $result = $service->fetchSomething(); if (! $result->isSuccess()) { throw new RuntimeException('Error fetching something'); } /* ... otherwise, complete the request ... */ } Use the ErrorHandler middleware to handle exceptions thrown by your middleware and report the error condition to your users. Middleware Stratigility provides several concrete middleware implementations. ErrorHandler and NotFoundHandler These two middleware allow you to provide handle PHP errors and exceptions, and 404 conditions, respectively. You may read more about them in the error handling chapter . OriginalMessages This callable middleware can be used as the outermost layer of middleware in order to set the original request, URI, and response instances as request attributes for inner layers. See the migration chapter for more details. Middleware Decorators Within MiddlewarePipe , if a response prototype is composed, callable middleware piped to the instance will be wrapped in a decorator. Two versions exist: Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable using the legacy interface; as such, it also requires a response instance: php $middleware = new CallableMiddlewareWrapper($middleware, $response); Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable that defines exactly two arguments, with the second type-hinting on the http-interop/http-middleware DelegateInterface : php $middleware = new CallableMiddlewareWrapper( function ($request, DelegateInterface $delegate) { // ... } ); You can manually decorate callable middleware using these decorators, or simply let MiddlewarePipe do the work for you. To let MiddlewarePipe handle this, however, you must compose a response prototype prior to piping middleware using the legacy middleware signature. Delegates In addition to Zend\\Stratigility\\Next , Stratigility provides another http-interop/http-middleware DelegateInterface implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator . This class can be used to wrap a callable $next instance for use in passing to an http-interop/http-middleware middleware interface process() method as a delegate; the primary use case is adapting functor middleware to work as http-interop middleware. As an example: // http-interop/http-middleware 0.2: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; // http-interop/http-middleware 0.4.1: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Stratigility\\Delegate\\CallableDelegateDecorator; class TimestampMiddleware implements ServerMiddlewareInterface { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { return $this->process($request, new CallableDelegateDecorator($next, $response)); } public function process( ServerRequestInterface $request, DelegateInterface $delegate ) { $response = $delegate->process($request); return $response->withHeader('X-Processed-Timestamp', time()); } }","title":"API Reference"},{"location":"v2/api/#api-reference","text":"The following make up the primary API of Stratigility.","title":"API Reference"},{"location":"v2/api/#middleware","text":"Zend\\Stratigility\\MiddlewarePipe is the primary application interface, and has been discussed previously. Its API is: namespace Zend\\Stratigility; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class MiddlewarePipe implements ServerMiddlewareInterface { public function pipe( string|callable|ServerMiddlewareInterface $path, callable|ServerMiddlewareInterface $middleware = null ); public function __invoke( ServerRequestInterface $request, ResponseInterface $response, $delegate ) : ResponseInterface; public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } pipe() takes up to two arguments. If only one argument is provided, $middleware will be assigned that value, and $path will be re-assigned to the value / ; this is an indication that the $middleware should be invoked for any path. If $path is provided, the $middleware will only be executed for that path and any subpaths.","title":"Middleware"},{"location":"v2/api/#next","text":"Zend\\Stratigility\\Next is primarily an implementation detail of middleware, and exists to allow delegating to middleware registered later in the stack. It is implemented both as a functor and as an http-interop/http-middleware DelegateInterface .","title":"Next"},{"location":"v2/api/#middleware_1","text":"Stratigility provides several concrete middleware implementations.","title":"Middleware"},{"location":"v2/api/#middleware-decorators","text":"Within MiddlewarePipe , if a response prototype is composed, callable middleware piped to the instance will be wrapped in a decorator. Two versions exist: Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable using the legacy interface; as such, it also requires a response instance: php $middleware = new CallableMiddlewareWrapper($middleware, $response); Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper will wrap a callable that defines exactly two arguments, with the second type-hinting on the http-interop/http-middleware DelegateInterface : php $middleware = new CallableMiddlewareWrapper( function ($request, DelegateInterface $delegate) { // ... } ); You can manually decorate callable middleware using these decorators, or simply let MiddlewarePipe do the work for you. To let MiddlewarePipe handle this, however, you must compose a response prototype prior to piping middleware using the legacy middleware signature.","title":"Middleware Decorators"},{"location":"v2/api/#delegates","text":"In addition to Zend\\Stratigility\\Next , Stratigility provides another http-interop/http-middleware DelegateInterface implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator . This class can be used to wrap a callable $next instance for use in passing to an http-interop/http-middleware middleware interface process() method as a delegate; the primary use case is adapting functor middleware to work as http-interop middleware. As an example: // http-interop/http-middleware 0.2: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; // http-interop/http-middleware 0.4.1: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Stratigility\\Delegate\\CallableDelegateDecorator; class TimestampMiddleware implements ServerMiddlewareInterface { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { return $this->process($request, new CallableDelegateDecorator($next, $response)); } public function process( ServerRequestInterface $request, DelegateInterface $delegate ) { $response = $delegate->process($request); return $response->withHeader('X-Processed-Timestamp', time()); } }","title":"Delegates"},{"location":"v2/creating-middleware/","text":"Creating Middleware To create middleware, write a callable capable of receiving minimally PSR-7 ServerRequest and Response objects, and a callback to call the next middleware in the chain. In your middleware, you can handle as much or as little of the request as you want, including delegating to other middleware in order to produce or return a response. As an example, consider the following middleware which will use an external router to map the incoming request path to a handler; if unable to map the request, it returns processing to the next middleware. use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; function ($req, DelegateInterface $delegate) use ($router) { $path = $req->getUri()->getPath(); // Route the path $route = $router->route($path); if (! $route) { return $delegate->process($req); } /** @var MiddlewareInterface $handler */ $handler = $route->getHandler(); return $handler->process($req, $delegate); } Middleware written in this way can be any of the following: Closures (as shown above) Functions Static class methods PHP array callbacks (e.g., [ $dispatcher, 'dispatch' ] , where $dispatcher is a class instance) Invokable PHP objects (i.e., instances of classes implementing __invoke() ) Objects implementing Interop\\Http\\ServerMiddleware\\MiddlewareInterface In all cases, if you wish to implement typehinting, the signature is: function ( Psr\\Http\\Message\\ServerRequestInterface $request, Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate ) : Psr\\Http\\Message\\ResponseInterface","title":"Creating Middleware"},{"location":"v2/creating-middleware/#creating-middleware","text":"To create middleware, write a callable capable of receiving minimally PSR-7 ServerRequest and Response objects, and a callback to call the next middleware in the chain. In your middleware, you can handle as much or as little of the request as you want, including delegating to other middleware in order to produce or return a response. As an example, consider the following middleware which will use an external router to map the incoming request path to a handler; if unable to map the request, it returns processing to the next middleware. use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; function ($req, DelegateInterface $delegate) use ($router) { $path = $req->getUri()->getPath(); // Route the path $route = $router->route($path); if (! $route) { return $delegate->process($req); } /** @var MiddlewareInterface $handler */ $handler = $route->getHandler(); return $handler->process($req, $delegate); } Middleware written in this way can be any of the following: Closures (as shown above) Functions Static class methods PHP array callbacks (e.g., [ $dispatcher, 'dispatch' ] , where $dispatcher is a class instance) Invokable PHP objects (i.e., instances of classes implementing __invoke() ) Objects implementing Interop\\Http\\ServerMiddleware\\MiddlewareInterface In all cases, if you wish to implement typehinting, the signature is: function ( Psr\\Http\\Message\\ServerRequestInterface $request, Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate ) : Psr\\Http\\Message\\ResponseInterface","title":"Creating Middleware"},{"location":"v2/error-handlers/","text":"Error Handlers In your application, you may need to handle error conditions: Errors raised by PHP itself (e.g., inability to open a file or database connection). Exceptions/throwables raised by PHP and/or code you write or consume. Inability of any middleware to handle a request. You can typically handle these conditions via middleware itself. Handling 404 conditions If no middleware is able to handle the incoming request, this is typically representative of an HTTP 404 status. Stratigility provides a barebones middleware that you may register in an innermost layer that will return a 404 condition, Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a response prototype instance that it will use to provide the 404 status and a message indicating the request method and URI used: // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); $app->pipe(new NotFoundHandler(new Response()); // execute application Note that it is the last middleware piped into the application! Since it returns a response, no deeper nested layers will execute once it has been invoked. If you would like a templated response, you will need to write your own middleware; such middleware might look like the following: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class NotFoundMiddleware implements ServerMiddlewareInterface { private $renderer; public function __construct( TemplateRendererInterface $renderer, ResponseInterface $response ) { $this->renderer = $renderer; $this->response = $response; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $this->response->withStatus(404); $response->getBody()->write( $this->renderer->render('error::404') ); return $response; } } Handling PHP errors and exceptions Zend\\Stratigility\\Middleware\\ErrorHandler is a middleware implementation to register as the outermost layer of your application (or close to the outermost layer). It does the following: Creates a PHP error handler that catches any errors in the error_handling() mask and throws them as ErrorException instances. Wraps the invocation of the delegate in a try/catch block: if no exception is caught, and the result is a response, it returns it. if no exception is caught, it raises an exception, which will be caught. any caught exception is transformed into an error response. To generate the error response, we provide the ability to inject a callable with the following signature into the ErrorHandler during instantiation: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface We provide a default implementation, Zend\\Stratigility\\Middleware\\ErrorResponseGenerator , which generates an error response with a 5XX series status code and a message derived from the reason phrase, if any is present. You may pass a boolean flag to its constructor indicating the application is in development mode; if so, the response will have the stack trace included in the body. In order to work, the ErrorHandler needs a prototype response instance, and, optionally, an error response generator (if none is provided, ErrorResponseGenerator is used, in production mode): // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); As a full example, you can combine the two middleware into the same application as separate layers: // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); // setup 404 handling $app->pipe(new NotFoundHandler(new Response()); // execute application The ErrorResponseGenerator provides no templating facilities, and only responds as text/html . If you want to provide a templated response, or a different serialization and/or markup format, you will need to write your own error response generator. As an example: use ErrorException; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Throwable; use Zend\\Stratigility\\Exception\\MissingResponseException; use Zend\\Stratigility\\Middleware\\ErrorHandler; class TemplatedErrorResponseGenerator { private $isDevelopmentMode; private $renderer; public function __construct( TemplateRendererInterface $renderer, $isDevelopmentMode = false ) { $this->renderer = $renderer; $this->isDevelopmentMode = $isDevelopmentMode; } public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response) { $response = $response->withStatus(500); $response->getBody()->write($this->renderer->render('error::error', [ 'exception' => $e, 'development_mode' => $this->isDevelopmentMode, ])); return $response; } } You would then pass this to the ErrorHandler : $app->pipe(new ErrorHandler( new Response(), new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode) )); ErrorHandler Listeners Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to attach listeners ; these are triggered when an error or exception is caught, and provided with the exception/throwable raised, the original request, and the final response. These instances are considered immutable, so listeners are for purposes of logging/monitoring only. Listeners must implement the following signature: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : void Attach listeners using ErrorHandler::attachListener() : $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) { $message = sprintf( '[%s] %s %s: %s', date('Y-m-d H:i:s'), $request->getMethod(), (string) $request->getUri(), $throwable->getMessage() ); $logger->error($message); });","title":"Error Handlers"},{"location":"v2/error-handlers/#error-handlers","text":"In your application, you may need to handle error conditions: Errors raised by PHP itself (e.g., inability to open a file or database connection). Exceptions/throwables raised by PHP and/or code you write or consume. Inability of any middleware to handle a request. You can typically handle these conditions via middleware itself.","title":"Error Handlers"},{"location":"v2/error-handlers/#handling-404-conditions","text":"If no middleware is able to handle the incoming request, this is typically representative of an HTTP 404 status. Stratigility provides a barebones middleware that you may register in an innermost layer that will return a 404 condition, Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a response prototype instance that it will use to provide the 404 status and a message indicating the request method and URI used: // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); $app->pipe(new NotFoundHandler(new Response()); // execute application Note that it is the last middleware piped into the application! Since it returns a response, no deeper nested layers will execute once it has been invoked. If you would like a templated response, you will need to write your own middleware; such middleware might look like the following: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class NotFoundMiddleware implements ServerMiddlewareInterface { private $renderer; public function __construct( TemplateRendererInterface $renderer, ResponseInterface $response ) { $this->renderer = $renderer; $this->response = $response; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $this->response->withStatus(404); $response->getBody()->write( $this->renderer->render('error::404') ); return $response; } }","title":"Handling 404 conditions"},{"location":"v2/error-handlers/#handling-php-errors-and-exceptions","text":"Zend\\Stratigility\\Middleware\\ErrorHandler is a middleware implementation to register as the outermost layer of your application (or close to the outermost layer). It does the following: Creates a PHP error handler that catches any errors in the error_handling() mask and throws them as ErrorException instances. Wraps the invocation of the delegate in a try/catch block: if no exception is caught, and the result is a response, it returns it. if no exception is caught, it raises an exception, which will be caught. any caught exception is transformed into an error response. To generate the error response, we provide the ability to inject a callable with the following signature into the ErrorHandler during instantiation: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface We provide a default implementation, Zend\\Stratigility\\Middleware\\ErrorResponseGenerator , which generates an error response with a 5XX series status code and a message derived from the reason phrase, if any is present. You may pass a boolean flag to its constructor indicating the application is in development mode; if so, the response will have the stack trace included in the body. In order to work, the ErrorHandler needs a prototype response instance, and, optionally, an error response generator (if none is provided, ErrorResponseGenerator is used, in production mode): // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); As a full example, you can combine the two middleware into the same application as separate layers: // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); // setup 404 handling $app->pipe(new NotFoundHandler(new Response()); // execute application The ErrorResponseGenerator provides no templating facilities, and only responds as text/html . If you want to provide a templated response, or a different serialization and/or markup format, you will need to write your own error response generator. As an example: use ErrorException; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Throwable; use Zend\\Stratigility\\Exception\\MissingResponseException; use Zend\\Stratigility\\Middleware\\ErrorHandler; class TemplatedErrorResponseGenerator { private $isDevelopmentMode; private $renderer; public function __construct( TemplateRendererInterface $renderer, $isDevelopmentMode = false ) { $this->renderer = $renderer; $this->isDevelopmentMode = $isDevelopmentMode; } public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response) { $response = $response->withStatus(500); $response->getBody()->write($this->renderer->render('error::error', [ 'exception' => $e, 'development_mode' => $this->isDevelopmentMode, ])); return $response; } } You would then pass this to the ErrorHandler : $app->pipe(new ErrorHandler( new Response(), new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode) ));","title":"Handling PHP errors and exceptions"},{"location":"v2/executing-middleware/","text":"Executing and composing middleware The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe instance. You can nest MiddlewarePipe instances to create groups of related middleware, and attach them using a base path so they only execute if that path is matched. $api = new MiddlewarePipe(); // API middleware collection $api->pipe(/* ... */); // repeat as necessary $app = new MiddlewarePipe(); // Middleware representing the application $app->pipe('/api', $api); // API middleware attached to the path \"/api\" Request path changes when path matched When you pipe middleware using a path (other than '' or '/'), the middleware is dispatched with a request that strips the matched segment(s) from the start of the path. Using the previous example, if the path /api/users/foo is matched, the $api middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without changes to its own internal routing. Handling errors While the above will give you a basic application, it has no error handling whatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler class: use Zend\\Diactoros\\Response; use Zend\\Stratigility\\Middleware\\ErrorHandler; $app->pipe(new ErrorHandler(new Response()); // Add more middleware... You can learn how to customize the error handler to your needs in the chapter on error handlers . Extending the MiddlewarePipe Another approach is to extend the Zend\\Stratigility\\MiddlewarePipe class itself, particularly if you want to allow attaching other middleware to your own middleware. In such a case, you will generally override the process() method to perform any additional logic you have, and then call on the parent in order to iterate through your stack of middleware: class CustomMiddleware extends MiddlewarePipe { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // perform some work... // delegate to parent parent::process($request, $delegate); // maybe do more work? } } Another approach using this method would be to override the constructor to add in specific middleware, perhaps using configuration provided. In this case, make sure to also call parent::__construct() to ensure the middleware queue is initialized; we recommend doing this as the first action of the method. use Zend\\Stratigility\\MiddlewarePipe; class CustomMiddleware extends MiddlewarePipe { public function __construct($configuration) { parent::__construct(); // do something with configuration ... // attach some middleware ... $this->pipe(/* some middleware */); } } These approaches are particularly suited for cases where you may want to implement a specific workflow for an application segment using existing middleware, but do not necessarily want that middleware applied to all requests in the application.","title":"Executing and composing middleware"},{"location":"v2/executing-middleware/#executing-and-composing-middleware","text":"The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe instance. You can nest MiddlewarePipe instances to create groups of related middleware, and attach them using a base path so they only execute if that path is matched. $api = new MiddlewarePipe(); // API middleware collection $api->pipe(/* ... */); // repeat as necessary $app = new MiddlewarePipe(); // Middleware representing the application $app->pipe('/api', $api); // API middleware attached to the path \"/api\"","title":"Executing and composing middleware"},{"location":"v2/executing-middleware/#handling-errors","text":"While the above will give you a basic application, it has no error handling whatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler class: use Zend\\Diactoros\\Response; use Zend\\Stratigility\\Middleware\\ErrorHandler; $app->pipe(new ErrorHandler(new Response()); // Add more middleware... You can learn how to customize the error handler to your needs in the chapter on error handlers .","title":"Handling errors"},{"location":"v2/executing-middleware/#extending-the-middlewarepipe","text":"Another approach is to extend the Zend\\Stratigility\\MiddlewarePipe class itself, particularly if you want to allow attaching other middleware to your own middleware. In such a case, you will generally override the process() method to perform any additional logic you have, and then call on the parent in order to iterate through your stack of middleware: class CustomMiddleware extends MiddlewarePipe { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // perform some work... // delegate to parent parent::process($request, $delegate); // maybe do more work? } } Another approach using this method would be to override the constructor to add in specific middleware, perhaps using configuration provided. In this case, make sure to also call parent::__construct() to ensure the middleware queue is initialized; we recommend doing this as the first action of the method. use Zend\\Stratigility\\MiddlewarePipe; class CustomMiddleware extends MiddlewarePipe { public function __construct($configuration) { parent::__construct(); // do something with configuration ... // attach some middleware ... $this->pipe(/* some middleware */); } } These approaches are particularly suited for cases where you may want to implement a specific workflow for an application segment using existing middleware, but do not necessarily want that middleware applied to all requests in the application.","title":"Extending the MiddlewarePipe"},{"location":"v2/install/","text":"Installation and Requirements Install this library using composer: $ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^2.0 Stratigility has the following dependencies (which are managed by Composer): psr/http-message , which provides the interfaces specified in PSR-7 , and type-hinted against in this package. In order to use Stratigility, you will need an implementation of PSR-7; one such package is Diactoros . http-interop/http-middleware , which provides the interfaces that will become PSR-15. This is pinned to 0.4.1+. zendframework/zend-escaper , used by the ErrorHandler middleware and the (legacy) FinalHandler implementation for escaping error messages prior to passing them to the response. You can provide your own request and response implementations if desired as long as they implement the PSR-7 HTTP message interfaces. Previous versions Version 1 documentation Later versions Version 3 (current) documentation","title":"Installation and Requirements"},{"location":"v2/install/#installation-and-requirements","text":"Install this library using composer: $ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^2.0 Stratigility has the following dependencies (which are managed by Composer): psr/http-message , which provides the interfaces specified in PSR-7 , and type-hinted against in this package. In order to use Stratigility, you will need an implementation of PSR-7; one such package is Diactoros . http-interop/http-middleware , which provides the interfaces that will become PSR-15. This is pinned to 0.4.1+. zendframework/zend-escaper , used by the ErrorHandler middleware and the (legacy) FinalHandler implementation for escaping error messages prior to passing them to the response. You can provide your own request and response implementations if desired as long as they implement the PSR-7 HTTP message interfaces.","title":"Installation and Requirements"},{"location":"v2/install/#previous-versions","text":"Version 1 documentation","title":"Previous versions"},{"location":"v2/install/#later-versions","text":"Version 3 (current) documentation","title":"Later versions"},{"location":"v2/middleware/","text":"Middleware What is middleware? Middleware is code that exists between the request and response, and which can take the incoming request, perform actions based on it, and either complete the response or pass delegation on to the next middleware in the queue. use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response; use Zend\\Diactoros\\Server; use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Stratigility\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\NoopFinalHandler; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $app->setResponsePrototype(new Response()); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES); // Landing page $app->pipe('/', function ($req, DelegateInterface $delegate) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $delegate->process($req); } $response = new Response(); $response->getBody()->write('Hello world!'); return $response; }); // Another page $app->pipe('/foo', function ($req, DelegateInterface $delegate) { $response = new Response(); $response->getBody()->write('FOO!'); return $response; }); // 404 handler $app->pipe(new NotFoundHandler(new Response()); $server->listen(new NoopFinalHandler()); In the above example, we have two examples of middleware. The first is a landing page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next middleware in the stack. The second middleware matches on the path /foo \u2014 meaning it will match /foo , /foo/ , and any path beneath. In that case, it will complete the response with its own message. If no paths match at this point, a \"final handler\" is composed by default to report 404 status. So, concisely put, middleware are PHP callables that accept a request object, and do something with it . http-interop middleware The above example demonstrates the using the interfaces from the http-interop project. http-interop is a project attempting to standardize middleware signatures. The signature of the 0.4 series server-side middleware, on which Stratigility 2.X is based, is: ```php namespace Interop\\Http\\ServerMiddleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; interface MiddlewareInterface { public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } interface DelegateInterface { public function process( ServerRequestInterface $request ) : ResponseInterface; } ``` Stratigility allows you to implement the http-interop/http-middleware middleware interface to provide middleware. Additionally, you can define callable middleware with the following signature, and it will be dispatched as http-interop middleware: php function( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; (The $request argument does not require a typehint when defining callable middleware, but we encourage its use.) Finally, to keep backwards compatibility with Stratigility v1, as well as other projects that have not yet adopted http-interop, we allow using the \"double-pass\" signature (so-called because you pass both a request and response object to the delegate): php function ( ServerRequestInterface $request, ResponseInterface $response, callable $next ) : ResponseInterface where $next is expected to have the following signature: php function ( ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface As such, the above example can also be written as follows: php $app->pipe('/', function ($request, $response, $next) { if (! in_array($request->getUri()->getPath(), ['/', ''], true)) { return $next($request, $response); } return new TextResponse('Hello world!'); }); Middleware can decide more processing can be performed by calling the $next callable (or, when defining http-interop middleware, $delegate ) passed during invocation. With this paradigm, you can build a workflow engine for handling requests \u2014 for instance, you could have middleware perform the following: Handle authentication details Perform content negotiation Perform HTTP negotiation Route the path to a more appropriate, specific handler Each middleware can itself be middleware, and can attach to specific paths, allowing you to mix and match applications under a common domain. As an example, you could put API middleware next to middleware that serves its documentation, next to middleware that serves files, and segregate each by URI: $app->pipe('/api', $apiMiddleware); $app->pipe('/docs', $apiDocMiddleware); $app->pipe('/files', $filesMiddleware); The handlers in each middleware attached this way will see a URI with that path segment stripped, allowing them to be developed separately and re-used under any path you wish. Within Stratigility, middleware can be: Any PHP callable that accepts, minimally, a PSR-7 ServerRequest and Response (in that order), and, optionally, a callable (for invoking the next middleware in the queue, if any). Any http-interop 0.4.1 - middleware . Zend\\Stratigility\\MiddlewarePipe implements Interop\\Http\\ServerMiddleware\\MiddlewareInterface . (Stratigility 2.0 series.) Any http-interop 0.5.0 - middleware . Zend\\Stratigility\\MiddlewarePipe implements Interop\\Http\\Server\\MiddlewareInterface . (Since Stratigility 2.1)","title":"Middleware"},{"location":"v2/middleware/#middleware","text":"What is middleware? Middleware is code that exists between the request and response, and which can take the incoming request, perform actions based on it, and either complete the response or pass delegation on to the next middleware in the queue. use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response; use Zend\\Diactoros\\Server; use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Stratigility\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\NoopFinalHandler; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $app->setResponsePrototype(new Response()); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES); // Landing page $app->pipe('/', function ($req, DelegateInterface $delegate) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $delegate->process($req); } $response = new Response(); $response->getBody()->write('Hello world!'); return $response; }); // Another page $app->pipe('/foo', function ($req, DelegateInterface $delegate) { $response = new Response(); $response->getBody()->write('FOO!'); return $response; }); // 404 handler $app->pipe(new NotFoundHandler(new Response()); $server->listen(new NoopFinalHandler()); In the above example, we have two examples of middleware. The first is a landing page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next middleware in the stack. The second middleware matches on the path /foo \u2014 meaning it will match /foo , /foo/ , and any path beneath. In that case, it will complete the response with its own message. If no paths match at this point, a \"final handler\" is composed by default to report 404 status. So, concisely put, middleware are PHP callables that accept a request object, and do something with it .","title":"Middleware"},{"location":"v2/migration/","text":"Migrating to version 2 Version 2 of Stratigility makes several breaking changes to the API in order to provide more flexibility, promote interoperability, and reduce complexity. To help you prepare your code for version 2, version 1.3.0 provides several forwards compatibility features to assist you in the process. However, some changes will still require changes to your code following the 2.0 release. Original request, response, and URI In the original 1.X releases, Stratigility would decorate the request and response instances with Zend\\Stratigility\\Http\\Request and Zend\\Stratigility\\Http\\Response , respectively. This was done to facilitate access to the incoming request in cases of nested layers, where the URI path may have been truncated ( Next truncates matched paths when executing a layer if a path was provided when piping the middleware). Internally, prior to 1.3, only Zend\\Stratigility\\FinalHandler was still using this functionality: It would query the original request to get the original URI when creating a 404 response message. It passes the decorated request and response instances to onerror handlers. Starting with 1.3.0, we now deprecate these message decorators, and recommend against their usage. If you still need access to the original request, response, or URI instance, we recommend the following: Pipe Zend\\Stratigility\\Middleware\\OriginalMessages as the outermost layer of your application. This will inject the following request attributes into layers beneath it: originalRequest , mapping to the request provided to it at invocation. originalResponse , mapping to the response provided to it at invocation. originalUri , mapping to the URI composed by the request provided to it at invocation. You can then access these values within other middleware: $originalRequest = $request->getAttribute('originalRequest'); $originalResponse = $request->getAttribute('originalResponse'); $originalUri = $request->getAttribute('originalUri'); Internally, starting with 1.3.0, we have updated the request decorator to add the originalRequest attribute, and the FinalHandler to check for this, instead of the decorated instance. Finally, if you are creating an onerror handler for the FinalHandler , update your typehints to refer to the PSR-7 request and response interfaces instead of the Stratigility decorators, if you aren't already. The Zend\\Stratigility\\Http classes, interfaces, and namespace are removed in version 2.0.0. Error handling Prior to version 1.3, the recommended way to handle errors was via error middleware , special middleware that accepts an additional initial argument representing an error. On top of this, we provide the concept of a \"final handler\", pseudo-middleware that is executed by the Next implementation when the middleware stack is exhausted, but no response has been returned. These approaches, however, have several shortcomings: No other middleware frameworks implement the error middleware feature, which means any middleware that calls $next() with the error argument will not work in those other systems, and error middleware written for Stratigility cannot be composed in other systems. The FinalHandler implementation hits edge cases when empty responses are intended. Neither combination works well with error or exception handlers. Starting in 1.3, we are promoting using standard middleware layers as error handlers, instead of using the existing error middleware/final handler system. The first step is to opt-in to having throwables and exceptions raised by middleware, instead of having the dispatcher catch them and then invoke middleware. Do this via the MiddlewarePipe::raiseThrowables() method: $pipeline = new MiddlewarePipe(); $pipeline->raiseThrowables(); Once you have done that you may start using some of the new functionality, as well as augmented existing functionality: NotFoundHandler middleware ErrorHandler middleware Zend\\Stratigility\\NoopFinalHandler (see next section) Updating your application to use these features will ensure you are forwards compatible with version 2 releases. No-op final handler When using the NotFoundHandler and ErrorHandler middleware (or custom middleware you drop in place of them), the FinalHandler implementation loses most of its meaning, as you are now handling errors and 404 conditions as middleware layers. However, you still need to ensure that the pipeline returns a response, regardless of how the pipeline is setup, and for that we still need some form of \"final\" handler that can do so. (In fact, starting in version 2, the $out argument is renamed to $delegate , and is a required argument of the MiddlewarePipe .) Starting in version 1.3, we now offer a Zend\\Stratigility\\NoopFinalHandler implementation, which simply returns the response passed to it. You can compose it in your application in one of two ways: By passing it explicitly when invoking the middleware pipeline. By passing it to Zend\\Diactoros\\Server::listen() . If you are not using Zend\\Diactoros\\Server to execute your application, but instead invoking your pipeline manually, use the following: $response = $app($request, $response, new NoopFinalHandler()); If you are using Zend\\Diactoros\\Server , you will need to pass the final handler you wish to use as an argument to the listen() method; that method will then pass that value as the third argument to MiddlewarePipe as shown above: $server->listen(new NoopFinalHandler()); Both approaches above are fully forwards compatible with version 2, and will work in all version 1 releases as well. (You can also compose your own custom final handler; it only needs to accept a request and a response, and be guaranteed to return a response instance.) To summarize: Call the raiseThrowables() method of your MiddlewarePipe instance to opt-in to the new error handling strategy. Use the new Zend\\Stratigility\\Middleware\\NotFoundHandler as the innermost layer of your application pipeline in order to provide 404 responses. Use the new Zend\\Stratigility\\Middleware\\ErrorHandler middleware as the outermost (or close to outermost) layer of your application pipeline in order to handle exceptions. Use the Zend\\Stratigility\\NoopFinalHandler as the $out argument when dispatching your application pipeline. http-interop compatibility http-middleware 0.2.0 and Stratigility 1.3 Starting in version 1.3.0, we offer compatibility with http-interop/http-middleware 0.2.0 . That version of the specification defines the following interfaces: namespace Interop\\Http\\Middleware; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; interface DelegateInterface { public function process(RequestInterface $request) : ResponseInterface; } interface MiddlewareInterface { public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface; } interface ServerMiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface; } The support in version 1.3.0 consists of the following: MiddlewarePipe now also implements ServerMiddlewareInterface , and allows piping either type of http-interop middleware. Next now also implements DelegateInterface . Dispatch is now capable of dispatching either http-interop middleware type, in addition to legacy callable middleware. Additionally, MiddlewarePipe will now allow composing a response prototype ; this is a PSR-7 ResponseInterface instance. If not set, the first time the pipeline is invoked via its __invoke() method, it will set the prototype from the provided $response argument. When present, any callable, non-error middleware piped to the pipeline will be wrapped in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper instance, which converts it into an http-interop middleware type; when processed, the response prototype will be passed to the callable for the response argument. http-middleware 0.4.1 and Stratigility 2.0 http-interop/http-middleware 0.4.1 introduces breaking changes in the interfaces, including the following: The namespace changes from Interop\\Http\\Middleware to Interop\\Http\\ServerMiddleware , signaling a change indicating that the project now only targets server-side middleware. The interface ServerMiddlewareInterface is now more simply MiddlewareInterface , as the namespace indicates its usage in server-side applications. Interop\\Http\\Middleware\\MiddlewareInterface , which targeted client-side middleware, was removed entirely. The method DelegateInterface::process now accepts specifically a Psr\\Http\\Message\\ServerRequestInterface , and not the more general RequestInterface . The first two changes required only a change in import statements to accommodate, and could have been imported in parallel to the 0.2.0 interfaces. However, the second represents a signature change, which has necessitated a major version bump in Stratigility in order to remain compatible. Stratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that version (and compatible versions) only. Additionally, starting in version 2.0.0, MiddlewarePipe will no longer implement Zend\\Stratigility\\MiddlewareInterface , and only implement the http-interop/http-middleware MiddlewareInterface . This has several repercussions. Callable middleware in version 1.3.0 Callable middleware can be used without change in version 1.3.0. However, we recommend updating your code to prepare for version 2.0.0. First, we recommend never using the $response argument provided to middleware. The reason for this recommendation is two-fold. First, the http-interop/http-middleware interfaces do not provide it, and, as such, using it within your middleware makes your middleware incompatible. Second, and more importantly, is due to the reason why http-interop does not include the argument: usage can lead to inconsistent and/or unexpected results. As an example, consider the following: use Zend\\Diactoros\\Response\\JsonResponse; $pipeline->pipe(function ($request, $response, $next) { return $next($request, $response->withHeader('X-Foo', 'Bar')); }); $pipeline->pipe(function ($request, $response, $next) { return new JsonResponse(['ack' => time()]); }); The first, outer layer of middleware sets a response header. However, the second, inner middleware, creates and returns an entirely new response , making the new header disappear. As such, we recommend rewriting such middleware to modify the returned response instead: use Zend\\Diactoros\\Response\\JsonResponse; $pipeline->pipe(function ($request, $response, $next) { $response = $next($request, $response); return $response->withHeader('X-Foo', 'Bar'); }); $pipeline->pipe(function ($request, $response, $next) { return new JsonResponse(['ack' => time()]); }); The above will have the expected result for whatever middleware is nested beneath it, as it will operate on the returned response, and have consistent results. Second, either wrap your middleware in CallableMiddlewareWrapper , or ensure your pipeline composes a response prototype (doing so will implicitly decorate callable middleware). Either of these will ensure your middleware will work with http-interop/http-middleware delegators. use Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper; // Manually decorating callable middleware for use with http-middleware: $pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response)); // Auto-decorate middleware by providing a response prototype: $pipeline->setResponsePrototype($response); $pipeline->pipe($middleware); CallableMiddlewareWrapper and Stratigility 2.0 As noted above, version 2 of Stratigility is incompatible with version 1.3 due to signature changes in the http-middleware project. However, if you wrap your callable middleware using CallableMiddlewareWrapper , you will need to make no changes in your application to make it forwards compatible. We recommend using this strategy if you need to do a stepped transition to Stratigility 2.0. Third, and optionally, you can make one or both of the following changes to your callable middleware: Typehint the final $next argument against Interop\\Http\\Middleware\\DelegateInterface ; optionally, rename it to $delegate . This will require a slight change to how you invoke the next layer as well; see below. Remove the $response argument from your signature; if you do, make sure you typehint the delegate argument, and make it required. As an example of the first: function ($request, $response, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader('X-Foo', 'Bar'); } As an example of adopting both practices: function ($request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader('X-Foo', 'Bar'); } At this point, you have essentially implemented Interop\\Http\\Middleware\\ServerMiddlewareInterface (with the notable exception of not type-hinting the $request argument). When you pipe such callable middleware to MiddlewarePipeline , it will be wrapped in a Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper , which simply proxies to the middleware when processed. DelegateInterface and Stratigility 2.0 Since the namespace within http-interop/http-middleware changes between version 0.2.0 and 0.4.1, the above strategy will require making changes multiple times: once when upgrading to Stratigility 1.3, and another when upgrading to 2.0. As such, we recommend instead decorating your callable middleware using the CallableMiddlewareWrapper , until such time as you can rewrite your middleware to implement the http-middleware 0.4.1 interfaces. Finally, if you are so inclined, you can rewrite your middleware to specifically implement one or the other of the http-interop/http-middleware interfaces. This is particularly relevant for class-based middleware, but can also be accomplished by using PHP 7 anonymous classes. As an example, consider the following middleware class: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\JsonResponse; class PingMiddleware { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { return new JsonResponse(['ack' => time()]); } } This could be rewritten as follows: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\JsonResponse; class PingMiddleware implements ServerMiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { return new JsonResponse(['ack' => time()]); } } If we were dealing with callable middleware instead: use Zend\\Diactoros\\Response\\JsonResponse; $pipeline->pipe(function ($request, $response, $next) { return new JsonResponse(['ack' => time()]); }); we could wrap this in an anonymous class instead: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\JsonResponse; $pipeline->pipe(new class implements ServerMiddlewareInterface { public function (ServerRequestInterface $request, DelegateInterface $delegate) { return new JsonResponse(['ack' => time()]); } }); Using anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support piping closures. If you want your middleware to work with either http-interop/http-middleware or with the pre-1.3.0 middleware signature, you can do that as well. To accomplish this, we provide Zend\\Stratigility\\Delegate\\CallableDelegateDecorator , which will wrap a callable $next such that it may be used as a DelegateInterface implementation: use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\Stratigility\\Delegate\\CallableDelegateDecorator; class PingMiddleware implements ServerMiddlewareInterface { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { return $this->process($request, new CallableDelegateDecorator($next, $response)); } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { return new JsonResponse(['ack' => time()]); } } Implementing http-interop between Stratigility 1.3 and 2.0 While you can write your middleware to implement the http-interop/http-middleware middleware interface, please be aware that if you do so, you will need to take additional steps when upgrading from 1.3 to 2.0. In most cases, you should be able to simply change the import statements within your class file. As an example, if you have the following in your Stratigility 1.3-based project: php use Interop\\Http\\Middleware\\DelegateInterface; use Interop\\Http\\Middleware\\ServerMiddlewareInterface; The imports would become: php use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface; To summarize: Never work with the provided $response argument, but instead manipulate the response returned from calling $next . Ensure your pipeline can decorate callable middleware as http-interop/http-middleware. Do this by injecting a response prototype in the pipeline prior to piping any middleware. ( Note: this is not necessary if all callable middleware defines exactly two parameters, with the second type-hinting on the http-interop DelegateInterface .) Consider adapting your callable middleware to follow the http-interop middleware signature ( function (ServerRequestInterface $request, DelegateInterface $delegate) ); this will make it forward-compatible. (Be aware that this may require changes in import statements between Stratigility 1.3 and 2.0.) Consider updating your class-based middleware to implement the http-interop/http-middleware server middleware interface, potentially keeping the __invoke() method for interoperability with existing callable-based middleware runners. (Be aware that this may require changes in import statements between Stratigility 1.3 and 2.0.) The first and last suggestions in this list are strongly recommended to ensure forwards compatibility with http-middleware, and to ensure your middleware works properly across middleware stacks. Callable middleware in version 2.0.0 Callable middleware may still be used; however, in order to pipe it to the pipeline, you must do one of the following: Inject a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory instance via the pipeline's setCallableMiddlewareDecorator() method, prior to piping callable middleware to the instance. This factory class requires a ResponseInterface in its constructor, and will use that response when creating CallableMiddlewareWrapper instances. php $factory = new CallableMiddlewareWrapperFactory(new Response()); $pipeline->setCallableMiddlewareDecorator($factory); Pass a response prototype before piping the callable middleware. If no CallableMiddlewareWrapperFactory is present, this prototype will be used to seed one for use with decorating callable middleware. php $pipeline->setResponsePrototype(new Response()); Manually decorate your middleware prior to passing it to the pipeline: php $pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response)); // or CallableInteropMiddlewareWrapper, if your middleware implements // the http-middleware signature already. Invoking MiddlewarePipe instances in version 2.0.0 Invocation of the outermost middleware can now be done in two ways: Using __invoke() . This now requires a third argument, $delegate , which may be one of a callable accepting ServerRequestInterface and ResponseInterface arguments, or a DelegateInterface instance (the former will be decorated as the latter, binding the response instance). This will be invoked only if the MiddlewarePipe 's internal queue is exhausted without returning a response, and must return a response itself. A good candidate for this is the NoopFinalHandler . Using process() . This argument requires a request and DelegateInterface instance; again, the DelegateInterface instance will only be invoked if the pipeline's internal queue is exhausted without returning a response. As examples: use Zend\\Stratigility\\NoopFinalHandler; use Zend\\Stratigility\\Delegate\\CallableDelegateDecorator; // Using __invoke(): $response = $pipeline($request, $response, new NoopFinalHandler()); // Using process(): $response = $pipeline->process($request, new CallableDelegateDecorator( new NoopFinalHandler(), $response )); Once you have done so, you can process the returned request via an emitter . Deprecated functionality The following classes, methods, and arguments are deprecated starting in version 1.3.0, and will be removed in version 2.0.0. Zend\\Stratigility\\FinalHandler (class) Zend\\Stratigility\\Dispatch (class); this class is marked internal already, but anybody extending Next and/or this class should be aware of its removal. Zend\\Stratigility\\ErrorMiddlewareInterface (interface); error middleware should now be implemented per the error handling section above . The $response argument to Zend\\Stratigility\\Next 's __invoke() method. The argument, and all following it, are ignored starting in 2.0.0; it is used in 1.3.0 to ensure backwards compatibility with existing middleware. The CallableMiddlewareWrapper also ensures that a response argument is populated and present when invoking callable middleware. The $err argument to Zend\\Stratigility\\Next 's __invoke() method. Starting in 1.3.0, if a non-null value is encountered, this method will now emit an E_USER_DEPRECATED notice, referencing this documentation. Zend\\Stratigility\\Http\\Request (class) Zend\\Stratigility\\Http\\ResponseInterface (interface) Zend\\Stratigility\\Http\\Response (class) Interface/signature changes The following signature changes were made with the 2.0.0 release: Zend\\Stratigility\\Next : The $done constructor argument was renamed to $nextDelegate , and now allows either callable or Interop\\Http\\ServerMiddleware\\DelegateInterface arguments. The $response argument to __invoke() was removed. The (optional) $err argument to __invoke() was removed. Removed functionality The following classes, methods, and arguments are removed starting in version 2.0.0. Zend\\Stratigility\\Dispatch (class) Zend\\Stratigility\\ErrorMiddlewareInterface (class) Zend\\Stratigility\\FinalHandler (class) Zend\\Stratigility\\MiddlewareInterface . Define your middleware as callables, or using http-interop/http-middleware interfaces instead. Zend\\Stratigility\\Utils::getArity() (static method); no longer used internally. The $err argument to Zend\\Stratigility\\Next 's __invoke() method. If passed, it will now be ignored. Zend\\Stratigility\\Http\\Request (class) Zend\\Stratigility\\Http\\ResponseInterface (interface) Zend\\Stratigility\\Http\\Response (class) The $response argument to middleware is deprecated; please see the section on callable middleware for details, and adapt your middleware to no longer use the argument. While the legacy callable signature will continue to work, we recommend implementing an http-interop/http-middleware interface.","title":"Migration"},{"location":"v2/migration/#migrating-to-version-2","text":"Version 2 of Stratigility makes several breaking changes to the API in order to provide more flexibility, promote interoperability, and reduce complexity. To help you prepare your code for version 2, version 1.3.0 provides several forwards compatibility features to assist you in the process. However, some changes will still require changes to your code following the 2.0 release.","title":"Migrating to version 2"},{"location":"v2/migration/#original-request-response-and-uri","text":"In the original 1.X releases, Stratigility would decorate the request and response instances with Zend\\Stratigility\\Http\\Request and Zend\\Stratigility\\Http\\Response , respectively. This was done to facilitate access to the incoming request in cases of nested layers, where the URI path may have been truncated ( Next truncates matched paths when executing a layer if a path was provided when piping the middleware). Internally, prior to 1.3, only Zend\\Stratigility\\FinalHandler was still using this functionality: It would query the original request to get the original URI when creating a 404 response message. It passes the decorated request and response instances to onerror handlers. Starting with 1.3.0, we now deprecate these message decorators, and recommend against their usage. If you still need access to the original request, response, or URI instance, we recommend the following: Pipe Zend\\Stratigility\\Middleware\\OriginalMessages as the outermost layer of your application. This will inject the following request attributes into layers beneath it: originalRequest , mapping to the request provided to it at invocation. originalResponse , mapping to the response provided to it at invocation. originalUri , mapping to the URI composed by the request provided to it at invocation. You can then access these values within other middleware: $originalRequest = $request->getAttribute('originalRequest'); $originalResponse = $request->getAttribute('originalResponse'); $originalUri = $request->getAttribute('originalUri'); Internally, starting with 1.3.0, we have updated the request decorator to add the originalRequest attribute, and the FinalHandler to check for this, instead of the decorated instance. Finally, if you are creating an onerror handler for the FinalHandler , update your typehints to refer to the PSR-7 request and response interfaces instead of the Stratigility decorators, if you aren't already. The Zend\\Stratigility\\Http classes, interfaces, and namespace are removed in version 2.0.0.","title":"Original request, response, and URI"},{"location":"v2/migration/#error-handling","text":"Prior to version 1.3, the recommended way to handle errors was via error middleware , special middleware that accepts an additional initial argument representing an error. On top of this, we provide the concept of a \"final handler\", pseudo-middleware that is executed by the Next implementation when the middleware stack is exhausted, but no response has been returned. These approaches, however, have several shortcomings: No other middleware frameworks implement the error middleware feature, which means any middleware that calls $next() with the error argument will not work in those other systems, and error middleware written for Stratigility cannot be composed in other systems. The FinalHandler implementation hits edge cases when empty responses are intended. Neither combination works well with error or exception handlers. Starting in 1.3, we are promoting using standard middleware layers as error handlers, instead of using the existing error middleware/final handler system. The first step is to opt-in to having throwables and exceptions raised by middleware, instead of having the dispatcher catch them and then invoke middleware. Do this via the MiddlewarePipe::raiseThrowables() method: $pipeline = new MiddlewarePipe(); $pipeline->raiseThrowables(); Once you have done that you may start using some of the new functionality, as well as augmented existing functionality: NotFoundHandler middleware ErrorHandler middleware Zend\\Stratigility\\NoopFinalHandler (see next section) Updating your application to use these features will ensure you are forwards compatible with version 2 releases.","title":"Error handling"},{"location":"v2/migration/#http-interop-compatibility","text":"","title":"http-interop compatibility"},{"location":"v2/migration/#deprecated-functionality","text":"The following classes, methods, and arguments are deprecated starting in version 1.3.0, and will be removed in version 2.0.0. Zend\\Stratigility\\FinalHandler (class) Zend\\Stratigility\\Dispatch (class); this class is marked internal already, but anybody extending Next and/or this class should be aware of its removal. Zend\\Stratigility\\ErrorMiddlewareInterface (interface); error middleware should now be implemented per the error handling section above . The $response argument to Zend\\Stratigility\\Next 's __invoke() method. The argument, and all following it, are ignored starting in 2.0.0; it is used in 1.3.0 to ensure backwards compatibility with existing middleware. The CallableMiddlewareWrapper also ensures that a response argument is populated and present when invoking callable middleware. The $err argument to Zend\\Stratigility\\Next 's __invoke() method. Starting in 1.3.0, if a non-null value is encountered, this method will now emit an E_USER_DEPRECATED notice, referencing this documentation. Zend\\Stratigility\\Http\\Request (class) Zend\\Stratigility\\Http\\ResponseInterface (interface) Zend\\Stratigility\\Http\\Response (class)","title":"Deprecated functionality"},{"location":"v2/migration/#interfacesignature-changes","text":"The following signature changes were made with the 2.0.0 release: Zend\\Stratigility\\Next : The $done constructor argument was renamed to $nextDelegate , and now allows either callable or Interop\\Http\\ServerMiddleware\\DelegateInterface arguments. The $response argument to __invoke() was removed. The (optional) $err argument to __invoke() was removed.","title":"Interface/signature changes"},{"location":"v2/migration/#removed-functionality","text":"The following classes, methods, and arguments are removed starting in version 2.0.0. Zend\\Stratigility\\Dispatch (class) Zend\\Stratigility\\ErrorMiddlewareInterface (class) Zend\\Stratigility\\FinalHandler (class) Zend\\Stratigility\\MiddlewareInterface . Define your middleware as callables, or using http-interop/http-middleware interfaces instead. Zend\\Stratigility\\Utils::getArity() (static method); no longer used internally. The $err argument to Zend\\Stratigility\\Next 's __invoke() method. If passed, it will now be ignored. Zend\\Stratigility\\Http\\Request (class) Zend\\Stratigility\\Http\\ResponseInterface (interface) Zend\\Stratigility\\Http\\Response (class) The $response argument to middleware is deprecated; please see the section on callable middleware for details, and adapt your middleware to no longer use the argument. While the legacy callable signature will continue to work, we recommend implementing an http-interop/http-middleware interface.","title":"Removed functionality"},{"location":"v2/usage/","text":"Usage Creating an application consists of 3 steps: Create middleware or a middleware pipeline Create a server, using the middleware Instruct the server to listen for a request use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Stratigility\\NoopFinalHandler; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); $server->listen(new NoopFinalHandler()); The above example is useless by itself until you pipe middleware into the application.","title":"Usage"},{"location":"v2/usage/#usage","text":"Creating an application consists of 3 steps: Create middleware or a middleware pipeline Create a server, using the middleware Instruct the server to listen for a request use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Stratigility\\NoopFinalHandler; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); $server->listen(new NoopFinalHandler()); The above example is useless by itself until you pipe middleware into the application.","title":"Usage"},{"location":"v3/api/","text":"API Reference The following make up the primary API of Stratigility. Middleware Zend\\Stratigility\\MiddlewarePipe is the primary application interface, and has been discussed previously. Its API is: namespace Zend\\Stratigility; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class MiddlewarePipe implements MiddlewareInterface, RequestHandlerInterface { public function pipe(MiddlewareInterface $middleware); public function handle(ServerRequestInterface $request) : ResponseInterface; public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } Middleware is executed in the order in which it is piped to the MiddlewarePipe instance. The MiddlewarePipe is itself middleware, and can be executed in stacks that expect PSR-15 middleware signatures. It is also a request handler, allowing you to use it in paradigms where a request handler is required; when executed in this way, it will process itself in order to generate a response. Middleware should either return a response, or the result of RequestHandlerInterface::handle() (which should eventually evaluate to a response instance). Internally, MiddlewarePipe creates an instance of Zend\\Stratigility\\Next to use as a RequestHandlerInterface implementation to pass to each middleware; Next receives the queue of middleware from the MiddlewarePipe instance and processes each one, calling them with the current request and itself, advancing its internal pointer until all middleware are executed, or a response is returned. Next Zend\\Stratigility\\Next is primarily an implementation detail, and exists to allow delegating to middleware aggregated in the MiddlewarePipe . It is implemented as an PSR-15 RequestHandlerInterface . Since your middleware needs to return a response, the instance receives the $handler argument passed to MiddlewarePipe::process() as a fallback request handler; if the last middleware in the queue calls on its handler, Next will execute the fallback request handler to generate a response to return. Providing an altered request: function ($request, RequestHandlerInterface $handler) use ($bodyParser) { $bodyParams = $bodyParser($request); // Delegate will receive the new request instance: return $handler->handle( $request->withBodyParams($bodyParams) ); } Providing an altered request and operating on the returned response: function ($request, RequestHandlerInterface $handler) use ($bodyParser) { $bodyParams = $bodyParser($request); // Provide a new request instance to the handler: $response = return $handler->handle( $request->withBodyParams($bodyParams) ); // Return a response with an additional header: return $response->withHeader('X-Completed', 'true'); } Returning a response to complete the request If your middleware does not need to delegate to another layer, it's time to return a response. We recommend creating a new response, or providing your middleware with a response prototype; this will ensure that the response is specific for your context. $prototype = new Response(); function ($request, RequestHandlerInterface $handler) use ($prototype) { $response = $prototype->withAddedHeader('Cache-Control', [ 'public', 'max-age=18600', 's-maxage=18600', ]); } Delegation If your middleware is not capable of returning a response, or a particular path in the middleware cannot return a response, return the result of executing the handler. return $handler->handle($request); Middleware should always return a response, and, if it cannot, return the result of delegating to the request handler. Raising an error condition If your middleware cannot complete \u2014 perhaps a database error occurred, a service was unreachable, etc. \u2014 how can you report the error? Raise an exception! function ($request, RequestHandlerInterface $handler) use ($service) { $result = $service->fetchSomething(); if (! $result->isSuccess()) { throw new RuntimeException('Error fetching something'); } /* ... otherwise, complete the request ... */ } Use the ErrorHandler middleware to handle exceptions thrown by your middleware and report the error condition to your users. Middleware Stratigility provides several concrete middleware implementations. PathMiddlewareDecorator If you wish to segregate middleware by path prefix and/or conditionally execute middleware based on a path prefix, decorate your middleware using Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . Middleware decorated by PathMiddlewareDecorator will only execute if the request URI matches the path prefix provided during instantiation. // Only process $middleware if the URI path prefix matches '/foo': $pipeline->pipe(new PathMiddlewareDecorator('/foo', $middleware)); When the path prefix matches, the PathMiddlewareDecorator will strip the path prefix from the request passed to the decorated middleware. For example, if you executed $pipeline->pipe('/api', $api) , and this was matched via a URI with the path /api/users/foo , the $api middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without changes to its own internal routing. CallableMiddlewareDecorator Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator provides the ability to decorate PHP callables that have the same signature as or a compatible signature to PSR-15's MiddlewareInterface . This allows for one-off middleware creation when creating your pipeline: $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) { // do some work $response = $handler->handle($req); // do some work return $response; }); DoublePassMiddlewareDecorator Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator provides the ability to decorate \"double-pass\", callable middleware (so-called because you pass the request and response to the delegate) within a class implementing the PSR-15 MiddlewareInterface . This allows you to adapt existing middleware with the double-pass interface to work with Stratigility. $pipeline->pipe(new DoublePassMiddlewareDecorator(function ($req, $res, $next) { // do some work $response = $next($req, $res); // do some work return $response; }); $next is a callable that decorates Stratigility's Next instance; it ignores the response argument. The constructor takes an optional second argument, a response prototype. This will be used to pass to the middleware when it is executed. If no instance is provided, a zend-diactoros response instance is auto-wired. If you want to use an alternate PSR-7 ResponseInterface implementation, pass it when creating the decorator instance: $pipeline->pipe(new DoublePassMiddlewareDecorator( $doublePassMiddleware, $response )); RequestHandlerMiddleware Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware allows you to decorate a PSR-15 RequestHandlerInterface for use as either a request handler or middleware. When either its handle() or process() method are called, it will proxy to the composed request handler's handle() method and return the response it produces. This can be useful for piping a final handler to a pipeline. // Where $handler is a RequestHandlerInterface: $pipeline->pipe(new RequestHandlerMiddleware($handler)); ErrorHandler and NotFoundHandler These two middleware allow you to provide handle PHP errors and exceptions, and 404 conditions, respectively. You may read more about them in the error handling chapter . OriginalMessages This callable middleware can be used as the outermost layer of middleware in order to set the original request and URI instances as request attributes for inner layers. Utility Functions Stratigility provides the following utility functions. host function Zend\\Stratigility\\host( string $host, Psr\\Http\\Server\\MiddlewareInterface $middleware ) : Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator host() provides a convenient way to perform host name segregation when piping your middleware. $pipeline->pipe(host('example.com', $middleware)); path function Zend\\Stratigility\\path( string $pathPrefix, Psr\\Http\\Server\\MiddlewareInterface $middleware ) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator path() provides a convenient way to perform path segregation when piping your middleware. $pipeline->pipe(path('/foo', $middleware)); middleware function Zend\\Stratigility\\middleware( callable $middleware ) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator middleware() provides a convenient way to decorate callable middleware that implements the PSR-15 middleware signature when piping it to your application. $pipeline->pipe(middleware(function ($request, $handler) { // ... }); doublePassMiddleware function Zend\\Stratigility\\doublePassMiddleware( callable $middleware, Psr\\Http\\Message\\ResponseInterface $responsePrototype = null ) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator doublePassMiddleware() provides a convenient way to decorate middleware that implements the double pass middleware signature when piping it to your application. $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) { // ... }); If you are not using zend-diactoros as a PSR-7 implementation, you will need to pass a response prototype as well: $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) { // ... }, $response);","title":"API Reference"},{"location":"v3/api/#api-reference","text":"The following make up the primary API of Stratigility.","title":"API Reference"},{"location":"v3/api/#middleware","text":"Zend\\Stratigility\\MiddlewarePipe is the primary application interface, and has been discussed previously. Its API is: namespace Zend\\Stratigility; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class MiddlewarePipe implements MiddlewareInterface, RequestHandlerInterface { public function pipe(MiddlewareInterface $middleware); public function handle(ServerRequestInterface $request) : ResponseInterface; public function process( ServerRequestInterface $request, DelegateInterface $delegate ) : ResponseInterface; } Middleware is executed in the order in which it is piped to the MiddlewarePipe instance. The MiddlewarePipe is itself middleware, and can be executed in stacks that expect PSR-15 middleware signatures. It is also a request handler, allowing you to use it in paradigms where a request handler is required; when executed in this way, it will process itself in order to generate a response. Middleware should either return a response, or the result of RequestHandlerInterface::handle() (which should eventually evaluate to a response instance). Internally, MiddlewarePipe creates an instance of Zend\\Stratigility\\Next to use as a RequestHandlerInterface implementation to pass to each middleware; Next receives the queue of middleware from the MiddlewarePipe instance and processes each one, calling them with the current request and itself, advancing its internal pointer until all middleware are executed, or a response is returned.","title":"Middleware"},{"location":"v3/api/#next","text":"Zend\\Stratigility\\Next is primarily an implementation detail, and exists to allow delegating to middleware aggregated in the MiddlewarePipe . It is implemented as an PSR-15 RequestHandlerInterface . Since your middleware needs to return a response, the instance receives the $handler argument passed to MiddlewarePipe::process() as a fallback request handler; if the last middleware in the queue calls on its handler, Next will execute the fallback request handler to generate a response to return.","title":"Next"},{"location":"v3/api/#middleware_1","text":"Stratigility provides several concrete middleware implementations.","title":"Middleware"},{"location":"v3/api/#utility-functions","text":"Stratigility provides the following utility functions.","title":"Utility Functions"},{"location":"v3/creating-middleware/","text":"Creating Middleware Middleware piped to a MiddlewarePipe MUST implement the PSR-15 middleware interface. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class MyMiddleware implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ) : ResponseInterface { // ... do something and return response // or call request handler: // return $handler->handle($request); } } Anonymous middleware For one-off middleware, particularly when debugging, you can use an anonymous class to implement MiddlewareInterface : $pipeline->pipe(new class implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $response = $handler->handle($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } }); Callable middleware Sometimes it's easier to eschew the MiddlewareInterface , particularly when creating a one-off middleware for debugging purposes. In those cases, you can create a PHP callable that follows the same signature of MiddlewareInterface::process() , and wrap it in a Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator instance: $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) { // do some work $response = $handler->($req); // do some work return $response; }); The typehints for the arguments are optional, but such callable middleware will receive ServerRequestInterface and RequestHandlerInterface instances, in that order. You may also use the middleware() utility function in place of new CallableMiddlewareDecorator() . Double-Pass middleware Prior to PSR-15, many PSR-7 frameworks and projects adopted a \"double-pass\" middleware definition: function ( ServerRequestInterface $request, ResponseInterface $response, callable $next ) : ResponseInterface where $next had the signature: function ( ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface The latter interface is the origin of the term \"double-pass\", as the implementation passes not a single argument, but two. (The $response argument was often used as a response prototype for middleware that needed to return a response.) Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator allows decorating such middleware within a PSR-15 MiddlewareInterface implementation, allowing it to be used in your Stratigility application. When using DoublePassMiddlewareDecorator , internally it will decorate the $handler instance as a callable. To use the decorator, pass it the double-pass middleware to decorate via the constructor: $pipeline->pipe(new DoublePassMiddlewareDecorator($middleware)); If you are not using zend-diactoros for your PSR-7 implementation, the decorator also accepts a second argument, a PSR-7 ResponseInterface prototype instance to pass to the double-pass middleware: $pipeline->pipe(new DoublePassMiddlewareDecorator( $middleware, $responsePrototype )); You may also use the doublePassMiddleware() utility function in place of new DoublePassMiddlewareDecorator() . Beware of operating on the response In many cases, poorly written double-pass middleware will manipulate the response provided to them and pass the manipulated version to $next . This is problematic if you mix standard PSR-15 and double-pass middleware, as the response instance is dropped when $next is called, as the decorator we provide will ignore the argument. If you notice such issues appearing, please report them to the project providing the double-pass middleware, and ask them to only operate on the returned response.","title":"Creating Middleware"},{"location":"v3/creating-middleware/#creating-middleware","text":"Middleware piped to a MiddlewarePipe MUST implement the PSR-15 middleware interface. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class MyMiddleware implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ) : ResponseInterface { // ... do something and return response // or call request handler: // return $handler->handle($request); } }","title":"Creating Middleware"},{"location":"v3/creating-middleware/#anonymous-middleware","text":"For one-off middleware, particularly when debugging, you can use an anonymous class to implement MiddlewareInterface : $pipeline->pipe(new class implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $response = $handler->handle($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } });","title":"Anonymous middleware"},{"location":"v3/creating-middleware/#callable-middleware","text":"Sometimes it's easier to eschew the MiddlewareInterface , particularly when creating a one-off middleware for debugging purposes. In those cases, you can create a PHP callable that follows the same signature of MiddlewareInterface::process() , and wrap it in a Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator instance: $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) { // do some work $response = $handler->($req); // do some work return $response; }); The typehints for the arguments are optional, but such callable middleware will receive ServerRequestInterface and RequestHandlerInterface instances, in that order. You may also use the middleware() utility function in place of new CallableMiddlewareDecorator() .","title":"Callable middleware"},{"location":"v3/creating-middleware/#double-pass-middleware","text":"Prior to PSR-15, many PSR-7 frameworks and projects adopted a \"double-pass\" middleware definition: function ( ServerRequestInterface $request, ResponseInterface $response, callable $next ) : ResponseInterface where $next had the signature: function ( ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface The latter interface is the origin of the term \"double-pass\", as the implementation passes not a single argument, but two. (The $response argument was often used as a response prototype for middleware that needed to return a response.) Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator allows decorating such middleware within a PSR-15 MiddlewareInterface implementation, allowing it to be used in your Stratigility application. When using DoublePassMiddlewareDecorator , internally it will decorate the $handler instance as a callable. To use the decorator, pass it the double-pass middleware to decorate via the constructor: $pipeline->pipe(new DoublePassMiddlewareDecorator($middleware)); If you are not using zend-diactoros for your PSR-7 implementation, the decorator also accepts a second argument, a PSR-7 ResponseInterface prototype instance to pass to the double-pass middleware: $pipeline->pipe(new DoublePassMiddlewareDecorator( $middleware, $responsePrototype )); You may also use the doublePassMiddleware() utility function in place of new DoublePassMiddlewareDecorator() .","title":"Double-Pass middleware"},{"location":"v3/error-handlers/","text":"Error Handlers In your application, you may need to handle error conditions: Errors raised by PHP itself (e.g., inability to open a file or database connection). Exceptions/throwables raised by PHP and/or code you write or consume. Inability of any middleware to handle a request. You can typically handle these conditions via middleware itself. Handling 404 conditions If no middleware is able to handle the incoming request, this is typically representative of an HTTP 404 status. Stratigility provides a barebones middleware that you may register in an innermost layer that will return a 404 condition, Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a response prototype instance that it will use to provide the 404 status and a message indicating the request method and URI used: // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); $app->pipe(new NotFoundHandler(new Response()); // execute application Note that it is the last middleware piped into the application! Since it returns a response, no deeper nested layers will execute once it has been invoked. If you would like a templated response, you will need to write your own middleware; such middleware might look like the following: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class NotFoundMiddleware implements MiddlewareInterface { private $renderer; public function __construct( TemplateRendererInterface $renderer, ResponseInterface $response ) { $this->renderer = $renderer; $this->response = $response; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) { $response = $this->response->withStatus(404); $response->getBody()->write( $this->renderer->render('error::404') ); return $response; } } Handling PHP errors and exceptions Zend\\Stratigility\\Middleware\\ErrorHandler is a middleware implementation to register as the outermost layer of your application (or close to the outermost layer). It does the following: Creates a PHP error handler that catches any errors in the error_handling() mask and throws them as ErrorException instances. Wraps the invocation of the delegate in a try/catch block: if no exception is caught, and the result is a response, it returns it. if no exception is caught, it raises an exception, which will be caught. any caught exception is transformed into an error response. To generate the error response, we provide the ability to inject a callable with the following signature into the ErrorHandler during instantiation: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface We provide a default implementation, Zend\\Stratigility\\Middleware\\ErrorResponseGenerator , which generates an error response with a 5XX series status code and a message derived from the reason phrase, if any is present. You may pass a boolean flag to its constructor indicating the application is in development mode; if so, the response will have the stack trace included in the body. In order to work, the ErrorHandler needs a prototype response instance, and, optionally, an error response generator (if none is provided, ErrorResponseGenerator is used, in production mode): // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); As a full example, you can combine the two middleware into the same application as separate layers: // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); // setup 404 handling $app->pipe(new NotFoundHandler(new Response()); // execute application The ErrorResponseGenerator provides no templating facilities, and only responds as text/html . If you want to provide a templated response, or a different serialization and/or markup format, you will need to write your own error response generator. As an example: use ErrorException; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Throwable; use Zend\\Stratigility\\Exception\\MissingResponseException; use Zend\\Stratigility\\Middleware\\ErrorHandler; class TemplatedErrorResponseGenerator { private $isDevelopmentMode; private $renderer; public function __construct( TemplateRendererInterface $renderer, $isDevelopmentMode = false ) { $this->renderer = $renderer; $this->isDevelopmentMode = $isDevelopmentMode; } public function __invoke(Throwable $e, ServerRequestInterface $request, ResponseInterface $response) { $response = $response->withStatus(500); $response->getBody()->write($this->renderer->render('error::error', [ 'exception' => $e, 'development_mode' => $this->isDevelopmentMode, ])); return $response; } } You would then pass this to the ErrorHandler : $app->pipe(new ErrorHandler( new Response(), new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode) )); ErrorHandler Listeners Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to attach listeners ; these are triggered when an error or exception is caught, and provided with the exception/throwable raised, the original request, and the final response. These instances are considered immutable, so listeners are for purposes of logging/monitoring only. Listeners must implement the following signature: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : void Attach listeners using ErrorHandler::attachListener() : $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) { $message = sprintf( '[%s] %s %s: %s', date('Y-m-d H:i:s'), $request->getMethod(), (string) $request->getUri(), $throwable->getMessage() ); $logger->error($message); });","title":"Error Handlers"},{"location":"v3/error-handlers/#error-handlers","text":"In your application, you may need to handle error conditions: Errors raised by PHP itself (e.g., inability to open a file or database connection). Exceptions/throwables raised by PHP and/or code you write or consume. Inability of any middleware to handle a request. You can typically handle these conditions via middleware itself.","title":"Error Handlers"},{"location":"v3/error-handlers/#handling-404-conditions","text":"If no middleware is able to handle the incoming request, this is typically representative of an HTTP 404 status. Stratigility provides a barebones middleware that you may register in an innermost layer that will return a 404 condition, Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a response prototype instance that it will use to provide the 404 status and a message indicating the request method and URI used: // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); $app->pipe(new NotFoundHandler(new Response()); // execute application Note that it is the last middleware piped into the application! Since it returns a response, no deeper nested layers will execute once it has been invoked. If you would like a templated response, you will need to write your own middleware; such middleware might look like the following: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class NotFoundMiddleware implements MiddlewareInterface { private $renderer; public function __construct( TemplateRendererInterface $renderer, ResponseInterface $response ) { $this->renderer = $renderer; $this->response = $response; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) { $response = $this->response->withStatus(404); $response->getBody()->write( $this->renderer->render('error::404') ); return $response; } }","title":"Handling 404 conditions"},{"location":"v3/error-handlers/#handling-php-errors-and-exceptions","text":"Zend\\Stratigility\\Middleware\\ErrorHandler is a middleware implementation to register as the outermost layer of your application (or close to the outermost layer). It does the following: Creates a PHP error handler that catches any errors in the error_handling() mask and throws them as ErrorException instances. Wraps the invocation of the delegate in a try/catch block: if no exception is caught, and the result is a response, it returns it. if no exception is caught, it raises an exception, which will be caught. any caught exception is transformed into an error response. To generate the error response, we provide the ability to inject a callable with the following signature into the ErrorHandler during instantiation: Psr\\Http\\Message\\ResponseInterface; Psr\\Http\\Message\\ServerRequestInterface; function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface We provide a default implementation, Zend\\Stratigility\\Middleware\\ErrorResponseGenerator , which generates an error response with a 5XX series status code and a message derived from the reason phrase, if any is present. You may pass a boolean flag to its constructor indicating the application is in development mode; if so, the response will have the stack trace included in the body. In order to work, the ErrorHandler needs a prototype response instance, and, optionally, an error response generator (if none is provided, ErrorResponseGenerator is used, in production mode): // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); As a full example, you can combine the two middleware into the same application as separate layers: // setup error handling $app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode)); // setup layers $app->pipe(/* ... */); $app->pipe(/* ... */); // setup 404 handling $app->pipe(new NotFoundHandler(new Response()); // execute application The ErrorResponseGenerator provides no templating facilities, and only responds as text/html . If you want to provide a templated response, or a different serialization and/or markup format, you will need to write your own error response generator. As an example: use ErrorException; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Throwable; use Zend\\Stratigility\\Exception\\MissingResponseException; use Zend\\Stratigility\\Middleware\\ErrorHandler; class TemplatedErrorResponseGenerator { private $isDevelopmentMode; private $renderer; public function __construct( TemplateRendererInterface $renderer, $isDevelopmentMode = false ) { $this->renderer = $renderer; $this->isDevelopmentMode = $isDevelopmentMode; } public function __invoke(Throwable $e, ServerRequestInterface $request, ResponseInterface $response) { $response = $response->withStatus(500); $response->getBody()->write($this->renderer->render('error::error', [ 'exception' => $e, 'development_mode' => $this->isDevelopmentMode, ])); return $response; } } You would then pass this to the ErrorHandler : $app->pipe(new ErrorHandler( new Response(), new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode) ));","title":"Handling PHP errors and exceptions"},{"location":"v3/executing-middleware/","text":"Executing and composing middleware The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe instance. You can nest MiddlewarePipe instances to create groups of related middleware, and attach them using a base path so they only execute if that path is matched. $api = new MiddlewarePipe(); // API middleware collection $api->pipe(/* ... */); // repeat as necessary $app = new MiddlewarePipe(); // Middleware representing the application $app->pipe(new PathMiddlewareDecorator('/api', $api)); // API middleware attached to the path \"/api\" Request path changes when path matched When you use the PathMiddlewareDecorator using a path (other than '' or '/'), the middleware it decorates is dispatched with a request that strips the matched segment(s) from the start of the path. Using the previous example, if the path /api/users/foo is matched, the $api middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without changes to its own internal routing. Handling errors While the above will give you a basic application, it has no error handling whatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler class: use Zend\\Diactoros\\Response; use Zend\\Stratigility\\Middleware\\ErrorHandler; $app->pipe(new ErrorHandler(new Response()); // Add more middleware... You can learn how to customize the error handler to your needs in the chapter on error handlers . Decorating the MiddlewarePipe Another approach is to compose a Zend\\Stratigility\\MiddlewarePipe instance within your own Psr\\Http\\Server\\MiddlewareInterface implementation, and optionally implementing the RequestHandlerInterface and/or pipe() method. In such a case, you might define the process() method to perform any additional logic you have, and then call on the decorated MiddlewarePipe instance in order to iterate through your stack of middleware: class CustomMiddleware implements MiddlewareInterface { private $pipeline; public function __construct(MiddlewarePipe $pipeline) { $this->pipeline = $pipeline; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // perform some work... // delegate to parent $this->pipeline->process($request, $handler); // maybe do more work? } } Another approach using this method would be to override the constructor to add in specific middleware, perhaps using configuration provided. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Stratigility\\MiddlewarePipe; class CustomMiddleware implements MiddlewareInterface { private $pipeline; public function __construct(array $configuration, MiddlewarePipe $pipeline) { // do something with configuration ... // attach some middleware ... $pipeline->pipe(/* some middleware */); $this->pipeline = $pipeline; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { /* ... */ } } These approaches are particularly suited for cases where you may want to implement a specific workflow for an application segment using existing middleware, but do not necessarily want that middleware applied to all requests in the application.","title":"Composing middleware"},{"location":"v3/executing-middleware/#executing-and-composing-middleware","text":"The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe instance. You can nest MiddlewarePipe instances to create groups of related middleware, and attach them using a base path so they only execute if that path is matched. $api = new MiddlewarePipe(); // API middleware collection $api->pipe(/* ... */); // repeat as necessary $app = new MiddlewarePipe(); // Middleware representing the application $app->pipe(new PathMiddlewareDecorator('/api', $api)); // API middleware attached to the path \"/api\"","title":"Executing and composing middleware"},{"location":"v3/executing-middleware/#handling-errors","text":"While the above will give you a basic application, it has no error handling whatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler class: use Zend\\Diactoros\\Response; use Zend\\Stratigility\\Middleware\\ErrorHandler; $app->pipe(new ErrorHandler(new Response()); // Add more middleware... You can learn how to customize the error handler to your needs in the chapter on error handlers .","title":"Handling errors"},{"location":"v3/executing-middleware/#decorating-the-middlewarepipe","text":"Another approach is to compose a Zend\\Stratigility\\MiddlewarePipe instance within your own Psr\\Http\\Server\\MiddlewareInterface implementation, and optionally implementing the RequestHandlerInterface and/or pipe() method. In such a case, you might define the process() method to perform any additional logic you have, and then call on the decorated MiddlewarePipe instance in order to iterate through your stack of middleware: class CustomMiddleware implements MiddlewareInterface { private $pipeline; public function __construct(MiddlewarePipe $pipeline) { $this->pipeline = $pipeline; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // perform some work... // delegate to parent $this->pipeline->process($request, $handler); // maybe do more work? } } Another approach using this method would be to override the constructor to add in specific middleware, perhaps using configuration provided. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Stratigility\\MiddlewarePipe; class CustomMiddleware implements MiddlewareInterface { private $pipeline; public function __construct(array $configuration, MiddlewarePipe $pipeline) { // do something with configuration ... // attach some middleware ... $pipeline->pipe(/* some middleware */); $this->pipeline = $pipeline; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { /* ... */ } } These approaches are particularly suited for cases where you may want to implement a specific workflow for an application segment using existing middleware, but do not necessarily want that middleware applied to all requests in the application.","title":"Decorating the MiddlewarePipe"},{"location":"v3/install/","text":"Installation and Requirements Install this library using composer: $ composer require zendframework/zend-diactoros zendframework/zend-stratigility Stratigility has the following dependencies (which are managed by Composer): psr/http-message , which provides the interfaces specified in PSR-7 , and type-hinted against in this package. In order to use Stratigility, you will need an implementation of PSR-7; one such package is Diactoros . psr/http-server-middleware , which provides the PSR-15 interfaces. zendframework/zend-escaper , used by the ErrorHandler middleware and the (legacy) FinalHandler implementation for escaping error messages prior to passing them to the response. You can provide your own request and response implementations if desired as long as they implement the PSR-7 HTTP message interfaces. Previous versions Version 1 documentation Version 2 documentation","title":"Installation and Requirements"},{"location":"v3/install/#installation-and-requirements","text":"Install this library using composer: $ composer require zendframework/zend-diactoros zendframework/zend-stratigility Stratigility has the following dependencies (which are managed by Composer): psr/http-message , which provides the interfaces specified in PSR-7 , and type-hinted against in this package. In order to use Stratigility, you will need an implementation of PSR-7; one such package is Diactoros . psr/http-server-middleware , which provides the PSR-15 interfaces. zendframework/zend-escaper , used by the ErrorHandler middleware and the (legacy) FinalHandler implementation for escaping error messages prior to passing them to the response. You can provide your own request and response implementations if desired as long as they implement the PSR-7 HTTP message interfaces.","title":"Installation and Requirements"},{"location":"v3/install/#previous-versions","text":"Version 1 documentation Version 2 documentation","title":"Previous versions"},{"location":"v3/intro/","text":"Stratigility From \"Strata\", Latin for \"layer\", and \"agility\". Stratigility started as a port of Sencha Connect to PHP. It allows you to build applications out of middleware . Previous versions Version 1 documentation Version 2 documentation","title":"Intro"},{"location":"v3/intro/#stratigility","text":"From \"Strata\", Latin for \"layer\", and \"agility\". Stratigility started as a port of Sencha Connect to PHP. It allows you to build applications out of middleware .","title":"Stratigility"},{"location":"v3/intro/#previous-versions","text":"Version 1 documentation Version 2 documentation","title":"Previous versions"},{"location":"v3/middleware/","text":"Middleware What is middleware? Middleware is code that exists between the request and response, and which can take the incoming request, perform actions based on it, and either complete the response or pass delegation on to the next middleware in the queue. // In public/index.php: use Zend\\Diactoros\\Response; use Zend\\Diactoros\\Server; use Zend\\Stratigility\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\MiddlewarePipe; use function Zend\\Stratigility\\middleware; use function Zend\\Stratigility\\path; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer([$app, 'handle'], $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES); // Landing page $app->pipe(middleware(function ($req, $handler) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $handler->handle($req); } $response = new Response(); $response->getBody()->write('Hello world!'); return $response; })); // Another page $app->pipe(path('/foo', middleware(function ($req, $handler) { $response = new Response(); $response->getBody()->write('FOO!'); return $response; }))); // 404 handler $app->pipe(new NotFoundHandler(function () { return new Response(); })); $server->listen(function ($req, $res) { return $res; }); In the above example, we have two examples of middleware. The first is a landing page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next middleware in the stack. The second middleware matches on the path /foo \u2014 meaning it will match /foo , /foo/ , and any path beneath. In that case, it will complete the response with its own message. If no paths match at this point, a \"final handler\" is composed by default to report 404 status. So, concisely put, middleware are PHP callables that accept a request object, and do something with it, optionally delegating creation of a response to another handler . PSR-15 middleware Stratigility supports only PSR-15 middleware. Middleware can decide more processing can be performed by calling the $handler instance passed during invocation. With this paradigm, you can build a workflow engine for handling requests \u2014 for instance, you could have middleware perform the following: Handle authentication details Perform content negotiation Perform HTTP negotiation Route the path to a more appropriate, specific handler Each middleware can itself be middleware. Using the provided PathMiddlewareDecorator (created by the path() function demonstrated in the initial example), you can also attach middleware to specific paths, allowing you to mix and match applications under a common domain. As an example, you could put API middleware next to middleware that serves its documentation, next to middleware that serves files, and segregate each by URI: $app->pipe(path('/api', $apiMiddleware)); $app->pipe(path('/docs', $apiDocMiddleware)); $app->pipe(path('/files', $filesMiddleware)); The handlers in each middleware attached this way will see a URI with that path segment stripped, allowing them to be developed separately and re-used under any path you wish. Within Stratigility, middleware must be PSR-15 middleware. Zend\\Stratigility\\MiddlewarePipe implements Psr\\Http\\Server\\MiddlewareInterface .","title":"Middleware"},{"location":"v3/middleware/#middleware","text":"What is middleware? Middleware is code that exists between the request and response, and which can take the incoming request, perform actions based on it, and either complete the response or pass delegation on to the next middleware in the queue. // In public/index.php: use Zend\\Diactoros\\Response; use Zend\\Diactoros\\Server; use Zend\\Stratigility\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\MiddlewarePipe; use function Zend\\Stratigility\\middleware; use function Zend\\Stratigility\\path; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer([$app, 'handle'], $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES); // Landing page $app->pipe(middleware(function ($req, $handler) { if (! in_array($req->getUri()->getPath(), ['/', ''], true)) { return $handler->handle($req); } $response = new Response(); $response->getBody()->write('Hello world!'); return $response; })); // Another page $app->pipe(path('/foo', middleware(function ($req, $handler) { $response = new Response(); $response->getBody()->write('FOO!'); return $response; }))); // 404 handler $app->pipe(new NotFoundHandler(function () { return new Response(); })); $server->listen(function ($req, $res) { return $res; }); In the above example, we have two examples of middleware. The first is a landing page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next middleware in the stack. The second middleware matches on the path /foo \u2014 meaning it will match /foo , /foo/ , and any path beneath. In that case, it will complete the response with its own message. If no paths match at this point, a \"final handler\" is composed by default to report 404 status. So, concisely put, middleware are PHP callables that accept a request object, and do something with it, optionally delegating creation of a response to another handler .","title":"Middleware"},{"location":"v3/migration/","text":"Migrating from version 2 to version 3 In this document, we outline the backwards breaking changes with version 3.0, and provide guidance on how to upgrade your application to be compatible. PHP support PSR-15 Pipeline ( MiddlewarePipe ) Changes in public interfaces Signature changes Class additions Removed classes and exceptions Removed methods Function additions PHP support We now support only PHP versions 7.1 and above. PHP 5.6 and 7.0 support has been dropped. PSR-15 Stratigility now supports only PSR-15 interfaces. Support of http-interop/http-middleware has been dropped. All middleware and request handlers must now implement PSR-15 interfaces, including those Stratigility implements. As a result, a number of signatures have been changed. Primarily, these were a matter of updating typehints on Interop\\Http\\ServerMiddleware\\DelegateInterface (defined in http-interop/http-middleware 0.4 and up, an early draft of PSR-15) and Interop\\Http\\Server\\RequestHandlerInterface (defined in http-interop/http-server-handler , the immediate predecessor to the final spec) to Psr\\Http\\Server\\RequestHandlerInterface , and adding the return type hint Psr\\Http\\Message\\ResponseInterface . Signatures affected include: Zend\\Stratigility\\MiddlewarePipe::process() Zend\\Stratigility\\Middleware\\ErrorHandler::process() Zend\\Stratigility\\Middleware\\NotFoundHandler::process() Zend\\Stratigility\\Middleware\\OriginalMessages::process() Zend\\Stratigility\\MiddlewarePipe::process() All of these classes now implement the PSR-15 MiddlewareInterface . Pipeline - MiddlewarePipe We now only allow piping Psr\\Http\\Server\\MiddlewareInterface instances into the MiddlewarePipe class. In version 2, we had a number of internal utilities for identifying other types of middleware (callable, double-pass, etc.), and would decorate those within the pipe() method. This is no longer allowed. If you wish to use those types, you will need to decorate them using the appropriate decorators as outlined in the Class additions section. Additionally, MiddlewarePipe is now marked final , and may not be directly extended. Decorate an instance if you wish to provide alternate behavior, or create your own MiddlewareInterface implementation to provide alternate internal logic. Changes in public interfaces Signature changes Next::__construct() : the second parameter now typehints against the PSR-15 RequestHandlerInterface . Next::handle() : the method now provides a return typehint of Psr\\Http\\Message\\ResponseInterface . MiddlewarePipe class is marked now as final and implements the new interface MiddlewarePipeInterface. MiddlewarePipe::pipe() : reduces the number of arguments to one, which now typehints against Psr\\Http\\Server\\MiddlewareInterface . This means the method can no longer be used to segregate middleware by path. If you want to do that, please use Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator to decorate your middleware and to provide the path prefix it will run under. See the next section for details. MiddlewarePipe::process() : the second parameter now typehints against Psr\\Http\\Server\\RequestHandlerInterface , and provides a return typehint of Psr\\Http\\Message\\ResponseInterface . ErrorHandler::__construct() and NotFoundHandler::__construct() : the first parameter of each constructor now expects a PHP callable capable of returning a PSR-7 ResponseInterface instance (instead of typehinting directly against ResponseInterface ). This paves the way for usage with the upcoming PSR-17 (HTTP Message Factories) specification, and simplifies re-use of a dependency injection container service (as otherwise you would need to specify a discrete service per class that expects a response prototype, due to mutability of the response body). Class additions Zend\\Stratigility\\MiddlewarePipeInterface extends Psr\\Http\\Server\\MiddlewareInterface and Psr\\Http\\Server\\RequestHandlerInterface , and defines the method pipe(Psr\\Http\\Server\\MiddlewareInterface $middleware) : void . It is implemented by MiddlewarePipe . Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator allows you to segregate middleware by a static host name. This allows executing middleware only if a particular host matches. php // Segregate to hosts matching 'example.com': $pipeline->pipe(new HostMiddlewareDecorator('example.com', $middleware)); Alternately, use the host() utility function to generate the instance; see below . Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator allows you to segregate middleware by a static URI path prefix. This allows executing middleware only if a particular path matches, or segregating a sub-application by path. php // Segregate to paths matching '/foo' as the prefix: $pipeline->pipe(new PathMiddlewareDecorator('/foo', $middleware)); Alternately, use the path() utility function to generate the instance; see below . Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator provides the functionality that was formerly provided by Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper : it provides the ability to decorate PHP callables that have the same or compatible signatures to the PSR-15 MiddlewareInterface . This allows for one-off piping of middleware: php $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) { // do some work $response = $next($req, $handler); // do some work return $response; }); The arguments and return value can be type-hinted, but do not need to be. The decorator provides some checking on the return value in order to raise an exception if a response is not returned. Alternately, use the middleware() utility function to generate the instance; see below . Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator provides the functionality that was formerly provided by Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper . The class now makes the response prototype argument to the constructor optional, and falls back to a zend-diactoros response instance if that library is installed. Internally, it decorates the $handler as a callable. php $pipeline->pipe(new DoublePassMiddlewareDecorator(function ($req, $res, $next) { // do some work $response = $next($req, $res); // do some work return $response; }); Per recommendations in previous versions, if you are using double-pass middleware, do not operate on the response passed to the middleware; instead, only operate on the response returned by $next , or produce a concrete response yourself. Alternately, use the doublePassMiddleware() utility function to create the instance; see below . Zend\\Stratigility\\Exception\\ExceptionInterface - marker for package-specific exceptions. Removed classes and exceptions The following classes have been removed: Zend\\Stratigility\\Delegate\\CallableDelegateDecorator Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory Zend\\Stratigility\\MiddlewareInterface (Please use the PSR-15 MiddlewareInterface instead.) Zend\\Stratigility\\NoopFinalHandler Zend\\Stratigility\\Route . This was an internal class used by MiddlewarePipe and Next , and its removal should not affect consumers. The following exceptions have been removed: Zend\\Stratigility\\Exception\\InvalidMiddlewareException (this is no longer thrown by MiddlewarePipe , and thus no longer necessary). Zend\\Stratigility\\Exception\\InvalidRequestTypeException Removed methods MiddlewarePipe::__invoke() : the class is no longer invokable. Use the method process instead. MiddlewarePipe::setCallableMiddlewareDecorator() : since we now accept only PSR-15 middleware implementations within MiddlewarePipe , this method is no longer needed. Other middleware types should be decorated in a MiddlewareInterface implementation prior to piping. MiddlewarePipe::setResponsePrototype() : this method is no longer needed, due to removing support for non- MiddlewareInterface types. MiddlewarePipe::hasResponsePrototype() : this method is no longer needed, due to removing support for non- MiddlewareInterface types. MiddlewarePipe::raiseThrowables() : this method has been deprecated since 2.0.0, and slated for removal with this version. Middleware\\ErrorHandler::__invoke() : this class is no longer invokable. Use the process method instead. Middleware\\NotFoundHandler::__invoke() : this class is no longer invokable. Use the process method instead. Next::__invoke() : this class is no longer invokable. Use the method handle instead. Next::next() : this method was a proxy to the handle() method, and no longer of use, particularly as the class is an internal detail. Next::process() : this method was a proxy to the handle() method, and no longer of use, particularly as the class is an internal detail. Next::raiseThrowables() : this method has been deprecated since 2.0.0, and slated for removal with this version. Function additions Release 3.0 adds the following utility functions: host function Zend\\Stratigility\\host( string $host, Psr\\Http\\Server\\MiddlewareInterface $middleware ) : Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator This is a convenience wrapper around instantiation of a Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator instance: $pipeline->pipe(host('example.com', $middleware)); path function Zend\\Stratigility\\path( string $pathPrefix, Psr\\Http\\Server\\MiddlewareInterface $middleware ) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator This is a convenience wrapper around instantiation of a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator instance: $pipeline->pipe(path('/foo', $middleware)); middleware function Zend\\Stratigility\\middleware( callable $middleware ) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator middleware() provides a convenient way to decorate callable middleware that implements the PSR-15 middleware signature when piping it to your application. $pipeline->pipe(middleware(function ($request, $handler) { // ... }); doublePassMiddleware function Zend\\Stratigility\\doublePassMiddleware( callable $middleware, Psr\\Http\\Message\\ResponseInterface $responsePrototype = null ) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator doublePassMiddleware() provides a convenient way to decorate middleware that implements the double pass middleware signature when piping it to your application. $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) { // ... }); If you are not using zend-diactoros as a PSR-7 implementation, you will need to pass a response prototype as well: $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) { // ... }, $response);","title":"Migration"},{"location":"v3/migration/#migrating-from-version-2-to-version-3","text":"In this document, we outline the backwards breaking changes with version 3.0, and provide guidance on how to upgrade your application to be compatible. PHP support PSR-15 Pipeline ( MiddlewarePipe ) Changes in public interfaces Signature changes Class additions Removed classes and exceptions Removed methods Function additions","title":"Migrating from version 2 to version 3"},{"location":"v3/migration/#php-support","text":"We now support only PHP versions 7.1 and above. PHP 5.6 and 7.0 support has been dropped.","title":"PHP support"},{"location":"v3/migration/#psr-15","text":"Stratigility now supports only PSR-15 interfaces. Support of http-interop/http-middleware has been dropped. All middleware and request handlers must now implement PSR-15 interfaces, including those Stratigility implements. As a result, a number of signatures have been changed. Primarily, these were a matter of updating typehints on Interop\\Http\\ServerMiddleware\\DelegateInterface (defined in http-interop/http-middleware 0.4 and up, an early draft of PSR-15) and Interop\\Http\\Server\\RequestHandlerInterface (defined in http-interop/http-server-handler , the immediate predecessor to the final spec) to Psr\\Http\\Server\\RequestHandlerInterface , and adding the return type hint Psr\\Http\\Message\\ResponseInterface . Signatures affected include: Zend\\Stratigility\\MiddlewarePipe::process() Zend\\Stratigility\\Middleware\\ErrorHandler::process() Zend\\Stratigility\\Middleware\\NotFoundHandler::process() Zend\\Stratigility\\Middleware\\OriginalMessages::process() Zend\\Stratigility\\MiddlewarePipe::process() All of these classes now implement the PSR-15 MiddlewareInterface .","title":"PSR-15"},{"location":"v3/migration/#pipeline-middlewarepipe","text":"We now only allow piping Psr\\Http\\Server\\MiddlewareInterface instances into the MiddlewarePipe class. In version 2, we had a number of internal utilities for identifying other types of middleware (callable, double-pass, etc.), and would decorate those within the pipe() method. This is no longer allowed. If you wish to use those types, you will need to decorate them using the appropriate decorators as outlined in the Class additions section. Additionally, MiddlewarePipe is now marked final , and may not be directly extended. Decorate an instance if you wish to provide alternate behavior, or create your own MiddlewareInterface implementation to provide alternate internal logic.","title":"Pipeline - MiddlewarePipe"},{"location":"v3/migration/#changes-in-public-interfaces","text":"","title":"Changes in public interfaces"},{"location":"v3/usage/","text":"Usage Creating an application consists of 3 steps: Create middleware or a middleware pipeline Create a server, using the middleware Instruct the server to listen for a request use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer( [$app, 'handle'], $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); $server->listen(function ($req, $res) { return $res; }); The above example is useless by itself until you pipe middleware into the application.","title":"Usage"},{"location":"v3/usage/#usage","text":"Creating an application consists of 3 steps: Create middleware or a middleware pipeline Create a server, using the middleware Instruct the server to listen for a request use Zend\\Stratigility\\MiddlewarePipe; use Zend\\Diactoros\\Server; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $server = Server::createServer( [$app, 'handle'], $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); $server->listen(function ($req, $res) { return $res; }); The above example is useless by itself until you pipe middleware into the application.","title":"Usage"}]}